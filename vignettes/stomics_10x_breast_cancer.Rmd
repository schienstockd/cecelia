---
title: "Run modules"
output: html_document
date: '2022-08-16'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Examples to run functions and modules

```{r}
# set test variables
pID <- "5g6H4F"
versionID <- 1
projectsDir <- "/Volumes/Analysis_SSD/Dominik/cecelia/projects/"
hpcDir <- "/data/scratch/projects/punim1124/cecelia/USERS/schienstockd/"
```

```{r}
anaDir <- "/Volumes/USER_data/Dominik/Experiments/stomics/10x/ANALYSIS"
```

```{r}
# Load cluster data
devtools::load_all("../")
cciaUse("~/cecelia/dev")

library(ggplot2)
library(tidyverse)
```

```{r}
# HPC config
HPC_CONF <-  list(
  hpc = list(
    conf = list(
      email = "schienstockd@student.unimelb.edu.au",
      emailOnBegin = FALSE,
      emailOnEnd = FALSE,
      emailOnFail = TRUE,
      numNodes = 1,
      numTasks = 1,
      numCPUperTask = 1,
      numGPUperTask = 1,
      memory = 50,
      # walltime = "00-12:00:00",
      # walltime = "00-01:00:00",
      walltime = "00-00:30:00",
      # walltime = "02-00:00:00",
      # projectPartitions = "physical",
      # projectID = "punim1124",
      # useGPU = FALSE
      projectPartitions = "gpu-a100",
      projectID = "punim1031",
      useGPU = TRUE
    )
  ),
  utils = list(
    ssh = list(
      username = "schienstockd",
      address = "spartan.hpc.unimelb.edu.au",
      keyfile = "/Users/Dominik/.ssh/spartan_rsa"
    ),
    python = list(
      condaEnv = cciaConf()$python$conda$source$env
    )
  )
)
```

```{r}
# upload STOMICS
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run cellpose
# run task
funParams <- list(
)

# run task
task <- cciaObj$runTask(
  funName = "hpc.uploadCciaObj",
  funParams = funParams,
  envVars = HPC_CONF,
  hpcDir = paste(hpcDir, pID, "ANALYSIS", sep = "/"),
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```


```{r}
# upload STOMICS
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)
```

```{r}
genes <- list(
  tumour_general = c("ABCC11", "AGR3", "DSP", "ERBB2", "FOXA1",
                     "GATA3", "S100A14", "SERPINA3", "TACSTD2"),
  tumour_dcis = c("AGR3", "CEACAM6", "MZB1", "SERPINA3"),
  tumour_invasive = c("FASN"),
  proliferative = c("MKI67", "TOP2A"),
  myoepithelium_1 = c("ACTA2", "DST", "KRT14", "KRT5", "MYLK"),
  myoepithelium_2 = c("KRT15", "KRT23", "PTN", "SFRP1"),
  stroma = c("ALDH1A3", "GJB2", "LUM", "MMP2", "POSTN", "SFRP4"),
  endothelial = c("AQP1", "EGFL7", "PECAM1", "VWF"),
  b_cells = c("BANK1", "CD79A", "MS4A1"),
  t_cells = c("CCL5", "CD4", "CD8A", "CXCR4", "CYTIP",
              "IL7R", "LTB", "TRAC"),
  macrophages = c("APOC1", "C15orf48", "C1QA", "C1QC", "CD14", "CD163",
                  "CD68", "FGL2", "ITGAX", "MMP12"),
  dendritic_cells = c("CCR7", "CD83", "IL3RA", "LILRA4", "PLD4"),
  mast_cells = c("CPA3", "CTSG", "KIT")
)
```

```{r}
# upload STOMICS
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run cellpose
# run task
funParams <- list(
  valueName = "default",
  # valueName = "stroma",
  models = list(
    # "1" = list(
    #   "model" = "ccia.fluo",
    #   # "model" = "cyto2",
    #   "matchAs" = "none",
    #   "cellDiameter" = 10,
    #   "cellChannels" = list("ALDH1A3", "GJB2", "LUM", "MMP2", "POSTN", "SFRP4"),
    #   "nucChannels" = list(),
    #   "normalise" = 98,
    #   "stitchThreshold" = 0.2,
    #   # "mergeLabels" = FALSE,
    #   "mergeLabels" = TRUE,
    #   "threshold" = 0,
    #   "relTreshold" = 0,
    #   "gaussianFilter" = 4,
    #   "sumFilter" = 0,
    #   "medianFilter" = 0
    # )
    # "1" = list(
    #   "model" = "cyto2",
    #   "matchAs" = "cyto",
    #   # "matchAs" = "none",
    #   "cellDiameter" = 10,
    #   "cellChannels" = list(
    #     "APOC1", "C15orf48", "C1QA", "C1QC", "CD14",
    #     "CD163", "CD68", "FGL2", "ITGAX", "MMP12",
    #     "CCR7", "CD83", "IL3RA", "LILRA4", "PLD4",
    #     "BANK1", "CD79A", "MS4A1", "CCL5", "CD4",
    #     "CD8A", "CXCR4", "CYTIP", "LTB", "TRAC"),
    #   "nucChannels" = list("Hoechst"),
    #   "normalise" = 99,
    #   "stitchThreshold" = 0.2,
    #   "mergeLabels" = FALSE,
    #   "threshold" = 1,
    #   "relTreshold" = 0,
    #   "gaussianFilter" = 0,
    #   "medianFilter" = 0
    # ),
    "1" = list(
      "model" = "cyto2",
      # "matchAs" = "nuc",
      "matchAs" = "none",
      "cellDiameter" = 10,
      "cellChannels" = list("Hoechst"),
      "nucChannels" = list(),
      "normalise" = 99,
      "stitchThreshold" = 0.2,
      "mergeLabels" = FALSE,
      "threshold" = 0,
      "relTreshold" = 0,
      "gaussianFilter" = 0,
      "medianFilter" = 0
    )
  ),
  clearDepth = FALSE,
  clearTouchingBorder = FALSE,
  # haloSize = 0,
  # haloWholeCell = FALSE,
  haloSize = 20, # for nuclei expansion
  haloWholeCell = TRUE,
  blockSize = 2048,
  # overlap = 120, # for larger structures
  # context = 40,
  overlap = 64,
  context = 52,
  blockSizeZ = -1,
  overlapZ = -1,
  segment = TRUE,
  # segment = FALSE,
  measure = TRUE,
  # measure = FALSE,
  updateMeasures = FALSE,
  # extendedMeasures = TRUE,
  extendedMeasures = FALSE,
  saveMeshes = FALSE,
  saveMeasures = TRUE,
  labelExpansion = 0,
  labelErosion = 0,
  minCellSize = 50,
  matchThreshold = 0.2,
  removeUnmatched = TRUE,
  labelOverlap = 0.2
  # labelOverlap = 0
)

# run task
task <- cciaObj$runTask(
  funName = "segment.cellpose",
  funParams = funParams,
  envVars = HPC_CONF,
  hpcDir = paste(hpcDir, pID, "ANALYSIS", sep = "/"),
  env = "hpc",
  # env = "local",
  runInplace = FALSE,
  # runInplace = TRUE,
  # taskID = 1
  taskID = 2
)
```

```{r}
# retrieve 
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run cellpose
# run task
funParams <- list(
  # valueNames = c("default", "stroma"),
  # valueNames = c("stroma"),
  valueNames = c("default"),
  retrieveMeshesOnly = FALSE
)

# run task
task <- cciaObj$runTask(
  funName = "segment.retrieve",
  funParams = funParams,
  envVars = HPC_CONF,
  hpcDir = paste(hpcDir, pID, "ANALYSIS", sep = "/"),
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# upload STOMICS
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run cellpose
# run task
funParams <- list(
)

# run task
task <- cciaObj$runTask(
  funName = "hpc.retrieveCciaObj",
  funParams = funParams,
  envVars = HPC_CONF,
  hpcDir = paste(hpcDir, pID, "ANALYSIS", sep = "/"),
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# upload STOMICS
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run task
funParams <- list(
  specialType = "tenxXenium",
  isSequence = FALSE
)

task <- cciaObj$runTask(
  funName = "importImages.upload",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# import STOMICS
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run task
funParams <- list(
  filterValue = 4
)

task <- cciaObj$runTask(
  funName = "importImages.tenxXenium",
  funParams = funParams,
  env = "hpc",
  runInplace = FALSE,
  taskID = 1
)
```

```{r}
# run population clustering
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "dpLvQE", versionID = versionID, initReactivity = FALSE
)

uIDs <- c("aSf5Rr")

# run task
funParams <- list(
  popType = "flow",
  popsToCluster = c(),
  savePops = FALSE,
  keepPops = FALSE,
  resolution = 0.1,
  mergeUmap = FALSE,
  normalisePercentile = 99.8,
  normalisePercentileBottom = 0,
  normaliseAxis = "channels",
  normaliseToMedian = FALSE,
  normaliseIndividually = FALSE,
  # transformation = "log",
  transformation = "NONE",
  logBase = 0,
  valueName = "default",
  uIDs = uIDs,
  clusterChannels = list(
    base = list(
      channels = c(0)
    )
  ),
  objectMeasures = c("area", "perimeter")
)

task <- cciaObj$runTask(
  funName = "clustPopulations.leidenClustering",
  funParams = funParams,
  env = "local",
  # runInplace = TRUE,
  runInplace = FALSE,
  taskID = 1
)
```

```{r}
# run population clustering
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "dpLvQE", versionID = versionID, initReactivity = FALSE
)

allChannelNames <- cciaObj$cciaObjects()[[1]]$imChannelNames()
# channelNames <- unname(allChannelNames[allChannelNames != "Hoechst"])

# get tumour and non-tumour first
# Then, use the rest of the genes to get a more detailed
# cluster map and try to make regions to see whether there are specific interactions
# in specific regions for these tumours
# Then, can you match that with the stroma branching?
geneGroups <- c("tumour", "myoepithelium", "endothelial")

channelNames <- unique(unlist(unname(genes[grepl(
# for all other genes
# channelNames <- unique(unlist(unname(genes[!grepl(
  paste0(geneGroups, collapse = "|"), names(genes))])))
channelNames <- channelNames[channelNames != "Hoechst"]

# get numbers
channelNames <- sapply(
  channelNames, function(x) {
    unname(which(allChannelNames == x)) - 1
  }, USE.NAMES = FALSE
)

uIDs <- c("aSf5Rr")

# Can you try to get tumour cells and others
# Then, make regions and see whether there are different
# cellular make ups in invasive and DCIS
# ie/ this section could be after IMC to show
# sequential Leiden clustering

# run task
funParams <- list(
  popType = "flow",
  popsToCluster = c(),
  # popsToCluster = c("/CD3"),
  # savePops = TRUE,
  savePops = FALSE,
  # keepPops = TRUE,
  keepPops = FALSE,
  # resolution = 1.0,
  resolution = 0.2,
  mergeUmap = TRUE,
  # mergeUmap = FALSE,
  normalisePercentile = 99.8,
  normalisePercentileBottom = 0,
  normaliseAxis = "channels",
  normaliseToMedian = FALSE,
  normaliseIndividually = FALSE,
  # transformation = "log",
  transformation = "NONE",
  logBase = 0,
  valueName = "default",
  uIDs = uIDs,
  clusterChannels = list(
    # halo = list(
    #   channels = channelNames
    # ),
    base = list(
      channels = channelNames
    )
  ),
  objectMeasures = c(
    "area", "perimeter", "solidity",
    "oblate", "prolate", "extent",
    "fill", "eccentricity"
  )
)

task <- cciaObj$runTask(
  funName = "clustPopulations.leidenClustering",
  funParams = funParams,
  env = "local",
  # runInplace = TRUE,
  runInplace = FALSE,
  taskID = 1
)

task$result(wait = TRUE)
```

```{r}
# create populations for branching
popType <- "clust"
valueName <- "default"

# add children
pops <- list(
  "invasive" = list(
    filterMeasure = "clusters",
    filterValues = "0",
    filterFun = "eq"
  )
)
parentPops <- "root"

# remove populations
cciaObj$delPopsByPath(
  popType,
  pops = levels(interaction(parentPops, names(pops), sep = "/")),
  includeFiltered = TRUE
)

# add populations
cciaObj$addFilteredPops(popType, parentPops, pops, valueName = valueName)

# save to disk
cciaObj$savePops(popType, purge = TRUE, includeFiltered = TRUE)

# save object
# cciaObj$saveState()
```

```{r}
# run population clustering
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "dpLvQE", versionID = versionID, initReactivity = FALSE
)

allChannelNames <- cciaObj$cciaObjects()[[1]]$imChannelNames()
channelNames <- unname(allChannelNames[allChannelNames != "Hoechst"])

# get numbers
channelNames <- sapply(
  channelNames, function(x) {
    unname(which(allChannelNames == x)) - 1
  }, USE.NAMES = FALSE
)

uIDs <- c("aSf5Rr")

# run task
funParams <- list(
  popType = "clust",
  popsToCluster = c("invasive"),
  # savePops = TRUE,
  savePops = FALSE,
  keepPops = TRUE,
  # keepPops = FALSE,
  resolution = 0.4,
  mergeUmap = TRUE,
  normalisePercentile = 99.8,
  normalisePercentileBottom = 0,
  normaliseAxis = "channels",
  normaliseToMedian = FALSE,
  normaliseIndividually = FALSE,
  # transformation = "log",
  transformation = "NONE",
  logBase = 0,
  valueName = "default",
  uIDs = uIDs,
  clusterChannels = list(
    # halo = list(
    #   channels = channelNames
    # ),
    base = list(
      channels = channelNames
    )
  ),
  objectMeasures = c(
    "area", "perimeter", "solidity",
    "oblate", "prolate", "extent",
    "fill", "eccentricity"
  )
)

task <- cciaObj$runTask(
  funName = "clustPopulations.leidenClustering",
  funParams = funParams,
  env = "local",
  # runInplace = TRUE,
  runInplace = FALSE,
  taskID = 1
)
```

```{r}
# plot out where the clusters are
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE
)

# get pops
popDT <- cciaObj$popDT(
  # popType = "clust", includeFiltered = TRUE, includeX = FALSE, completeDT = TRUE)
  popType = "flow")
  # popCols = c("label", "clusters", "UMAP_1", "UMAP_2"))
```

```{r fig_clust_spatial, fig.height=5, fig.width=13}
# plot out
for (i in unique(popDT$clusters)) {
  x <- popDT[clusters == i]
  y <- popDT[clusters != i]

  p1 <- ggplot(y, aes(centroid_x, centroid_y)) +
    theme_classic() +
    geom_point(data = y, size = 1, color = "#5B5B5B") +
    # geom_point(data = x, size = 1, color = "#FFCD2E") +
    geom_point(data = x, size = 1, color = .flowColours(x$centroid_x, x$centroid_y)) +
    coord_fixed() +
    plotThemeDark(angle = 0) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      legend.position = "none"
    )
  
  print(p1)
  
  ggsave(file.path(anaDir, "clusters", "indv", paste0("aSf5Rr_cluster_", i, ".png")), height = 10, width = 13)
}
```

```{r fig_clust_spatial, fig.height=8, fig.width=13}
# plot out
# x.ki67 <- popDT[pop == "invasive.KI67"]
x.ki67 <- popDT[pop %in% c("invasive", "invasive.KI67")]
x.branching <- unique(popStroma %>%
  dplyr::filter(
    startsWith(pop, "invasive"),
    # `branch-type` > 0
    ) %>%
  select(stroma.centroid_x, stroma.centroid_y))
y <- popDT[!clusters %in% tumourClusters]

ggplot(popDT, aes(centroid_x, centroid_y)) +
  theme_classic() +
  geom_point(data = y, size = 1, color = "#5B5B5B") +
  geom_point(data = x.ki67, size = 4, color = .flowColours(
    x.ki67$centroid_x, x.ki67$centroid_y,
    # colramp = colorRampPalette(rev(RColorBrewer::brewer.pal(9, "Purples")))
    colramp = colorRampPalette(viridisLite::viridis(n = 8))
    )) +
  geom_point(data = x.branching, size = 3, aes(stroma.centroid_x, stroma.centroid_y),
             shape = 21, stroke = 0.5,
             fill = .flowColours(
    x.branching$stroma.centroid_x, x.branching$stroma.centroid_y
    # colramp = colorRampPalette(RColorBrewer::brewer.pal(6, "Greens"))
    )) +
  coord_fixed() +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

# ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_tumour.png")), height = 10, width = 13)
ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_invasive_branching.png")), height = 10, width = 13)
```

```{r fig_clust_spatial, fig.height=5, fig.width=13}
# plot out
limY <- quantile(popDT$MKI67, probs = 0.99)[[1]]

ggplot(popDT, aes(centroid_x, centroid_y, z = MKI67)) +
  theme_classic() +
  stat_summary_2d(bins = 128) +
  viridis::scale_fill_viridis(limits = c(0, limY)) +
  coord_fixed() +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

ggsave(file.path(anaDir, "clusters", "markers", paste0("aSf5Rr_markers_MKI67.png")), height = 10, width = 13)
```

```{r}
excludeCols <- c("label", "clusters", "pop", "UMAP_1", "UMAP_2", "centroid_x", "centroid_y")
colsToShow <- colnames(popDT)[!colnames(popDT) %in% excludeCols]

# show heatmap
markersToPlot <- popDT %>%
  pivot_longer(
    cols = all_of(colsToShow), names_to = "marker", values_to = "value"
    )
markersToPlot$marker <- as.factor(markersToPlot$marker)

# show heatmap for clusters
markersSummary <- markersToPlot %>%
  drop_na() %>%
  group_by(marker, clusters) %>%
  summarise(mean = mean(value, rm.na = TRUE)) %>%
  mutate(norm = (mean - min(mean))/(max(mean) - min(mean))) %>%
  replace_na(list(norm = 0))

# find order for clusters and markers
markersMatrix <- markersSummary %>%
  pivot_wider(names_from = marker, values_from = norm, id_cols = "clusters")

hcClusters <- hclust(dist(as.matrix(markersMatrix %>% dplyr::select(-clusters))), "ave")
hcMarkers <- hclust(dist(t(as.matrix(markersMatrix %>% dplyr::select(-clusters)))), "ave")

clustersOrder <- markersMatrix$clusters[hcClusters$order]
markerOrder <- colnames(markersMatrix)[2:length(colnames(markersMatrix))][hcMarkers$order]

markersSummary <- markersSummary %>%
  mutate(
    clusters = factor(clusters, levels = sort(as.numeric(levels(clustersOrder)))),
    marker = factor(marker, levels = markerOrder)
  )
```


```{r fig_heat, fig.height=20, fig.width=20}
p1 <- ggplot(markersSummary, aes(clusters, marker)) +
  theme_classic() +
  # geom_tile(aes(fill = mean), colour = "white", size = 0.5) +
  geom_tile(aes(fill = norm), colour = "white", size = 0.5) +
  viridis::scale_fill_viridis(
    breaks = c(0, 1),
    labels = c(0, 1)
  ) +
  theme(
    legend.position = "none",
    legend.title = element_blank(),
    legend.text = element_text(size = 20),
    legend.key.size = unit(10, "mm"),
    # axis.text.y = element_text(size = 20),
    # axis.text.x = element_text(size = 20),
    axis.text.x = element_text(size = 10, angle = 90, hjust = 1, vjust = 1),
    strip.background = element_blank(),
    strip.text.x = element_blank()
    ) +
  xlab("") + ylab("") +
  coord_flip()

# ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_heat.pdf")), height = 49, width = 8)
ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_heat.pdf")), plot = p1, height = 8, width = 49)
```

```{r}
# define populations
popMap <- list(
  "Malignant.ESR-" = c("0", "4"),
  "Malignant.ESR+" = c("3"),
  "Malignant.KI67+" = c("9"),
  "FoxP3+ T cells" = c("1"),
  "Stroma" = c("2"),
  # "Malignant.ESRlo" = c("4"),
  "CD86+ Macro" = c("5"),
  "Undefined" = c("6"),
  "CD8+ T cells" = c("7"),
  "CLEC14A+" = c("8")
)
```

```{r fig_clust_spatial_pops, fig.height=5, fig.width=13}
popDT$clusters.pop <- "NONE"

for (i in names(popMap)) {
  for (y in popMap[[i]])
    popDT[clusters == y, clusters.pop := i]
}

# plot out
p1 <- ggplot(popDT[clusters.pop %in% c(
  "Malignant.ESR-", "Malignant.ESR+", "Malignant.KI67+", "FoxP3+ T cells",
  "Macro", "CD8+ T cells", "CD86+ Macro"
)], aes(centroid_x, centroid_y, color = clusters.pop)) +
  scale_color_brewer(name = NULL, palette = "Set1") +
  theme_classic() +
  geom_point(size = 0.2) +
  coord_fixed() +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank(),
    legend.key.size = unit(5, "mm"),
    legend.text = element_text(size = 18),
  ) + guides(colour = guide_legend(override.aes = list(size = 4)))
p2 <- p1 + theme(legend.position = "none")
  
ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_pops.png")), plot = p1, height = 10, width = 13)
ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_pops_wo_legend.png")), plot = p2, height = 10, width = 13)
```

```{r fig_pops_umap, fig.height=2, fig.width=2}
library(tidyverse)

# datToPlot <- popDT[clusters != "7"]
datToPlot <- popDT

# get mean positions of clusters
meanClusterPos <- datToPlot %>%
  group_by(clusters) %>%
  summarise(
    UMAP_1 = mean(UMAP_1),
    UMAP_2 = mean(UMAP_2)
  )

clustersPalette <- randomcoloR::distinctColorPalette(
  length(unique(datToPlot$clusters)))

# plot UMAP with paga connections
ggplot(
  datToPlot %>%
    mutate(clusters = factor(clusters, levels = clustersOrder)),
  aes(UMAP_1, UMAP_2)
  ) +
  theme_classic() +
  geom_point(aes(color = as.factor(clusters)), size = 0.5) +
  # scale_color_brewer(name = NULL, palette = "Set1") +
  scale_color_manual(values = clustersPalette) +
  theme(
    axis.text = element_text(size = 15),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.justification = "center",
    legend.direction = "horizontal",
    legend.position = "bottom",
    # legend.position = "none",
    legend.title = element_blank(),
    legend.key.size = unit(5, "mm"),
    legend.text = element_text(size = 18),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
    ) +
  guides(colour = guide_legend(override.aes = list(size = 4)))
  # geom_label(
  #   data = meanClusterPos,
  #   aes(label = clusters),
  #   label.size = 0.25,
  #   color = "black"
  #   )

ggsave(file.path(anaDir, "clusters", "aSf5Rr_umap.tiff"), width = 5, height = 6.5)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE
)

# run task
funParams <- list(
  valueName = "stroma",
  preDilationSize = 20,
  postDilationSize = 2
)

# run task
task <- cciaObj$runTask(
  funName = "segment.createBranching",
  funParams = funParams,
  env = "local",
  runInplace = FALSE,
  taskID = 1
)
```

```{r}
# get branching of stroma network
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

pops <- unlist(unname(cciaObj$popPaths("branch", includeFiltered = TRUE)))

branchingDT <- cciaObj$popDT("branch", pops = pops, popCols = c("branching-type"),
                             includeFiltered = TRUE)

spatialDT <- cciaObj$spatialDT("default")

# merge pops
spatialDT[popDT[, c("label", "pop")],
          on = c("to" = "label"),
          pop.to := pop]
spatialDT[popDT[, c("label", "pop")],
          on = c("from" = "label"),
          pop.from := pop]
```

```{r}
# xDT <- branchingDT[`branch-type` > 0]
xDT <- branchingDT

# show distance of tumour to stroma
popNN <- dbscan::kNN(
  as.matrix(xDT[, c('centroid_y', 'centroid_x')]),
  k = 1,
  query = as.matrix(popDT[, c('centroid_y', 'centroid_x')]))

popStroma <- copy(popDT)

# assign dists to pops
popStroma[, stroma.dist := popNN$dist]
popStroma[, stroma.id := popNN$id]
popStroma[, stroma.contact := FALSE]
popStroma[stroma.dist <= 100, stroma.contact := TRUE]

# merge branching info
popStroma[xDT[, c("label", "centroid_x", "centroid_y", "branch-type", "branch-distance")],
      on = c("stroma.id" = "label"),
      `:=` (
        stroma.centroid_x = i.centroid_x,
        stroma.centroid_y = i.centroid_y,
        `branch-type` = `branch-type`,
        `branch-distance` = `branch-distance`
        )]
```

```{r fig_clust_spatial, fig.height=5, fig.width=13}
# plot out
y <- popDT[!clusters %in% tumourClusters]

x <- unique(popStroma %>%
  dplyr::filter(
    startsWith(pop, "invasive")
    # `branch-type` > 0
    ) %>%
  select(stroma.centroid_x, stroma.centroid_y))

ggplot(popDT, aes(centroid_x, centroid_y)) +
  theme_classic() +
  geom_point(data = y, size = 1, color = "#5B5B5B") +
  geom_point(data = x, size = 2,
             aes(stroma.centroid_x, stroma.centroid_y),
             color = .flowColours(x$stroma.centroid_x, x$stroma.centroid_y)) +
  # geom_density_2d_filled(
  #   alpha = 0.5, data = x, aes(stroma.centroid_x, stroma.centroid_y)) +
  # geom_density_2d(
  #   color = "white", size = 1.5,
  #   data = x, aes(stroma.centroid_x, stroma.centroid_y)) +
  # viridis::scale_fill_viridis(option = "inferno", discrete = TRUE) +
  coord_fixed() +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_tumour_branching.png")), height = 10, width = 13)
```

```{r fig_branching, fig.height=5, fig.width=13}
# can you show tumour and stroma network?
# limY <- quantile(branchingDT$`branch-distance`, probs = 0.98)[[1]]
# limY <- quantile(branchingDT$`euclidean-distance`, probs = 0.98)[[1]]

# ggplot(branchingDT, aes(centroid_x, centroid_y, color = as.factor(`branch-type`))) +
# ggplot(branchingDT, aes(centroid_x, centroid_y, color = `branch-distance`)) +
# ggplot(branchingDT, aes(centroid_x, centroid_y, color = `euclidean-distance`)) +
ggplot(datX, aes(stroma.centroid_x, stroma.centroid_y)) +
  theme_classic() +
  geom_point(size = 1, color = .flowColours(
    datX$stroma.centroid_x, datX$stroma.centroid_y)) +
  coord_fixed() +
  # scale_color_brewer(palette = "Set1") +
  # viridis::scale_colour_viridis(limits = c(0, limY)) +
  # viridis::scale_colour_viridis() +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

# ggsave(file.path(anaDir, 'clusters', 'aSf5Rr_branching_type.png'), height = 20, width = 30)
# ggsave(file.path(anaDir, 'clusters', 'aSf5Rr_branching_dist.png'), height = 20, width = 30)
# ggsave(file.path(anaDir, 'clusters', 'aSf5Rr_branching_density.png'), height = 20, width = 30)
```

```{r fig_branching_heat, fig.height=5, fig.width=13}
# show heatplots
branchingDT[, branch_pocket := 0]
branchingDT[`branch-type` > 0, branch_pocket := 1]

# for (i in unique(branchingDT$`branch-type`)) {
for (i in unique(branchingDT$branch_pocket)) {
  # xDT <- branchingDT[`branch-type` == i]
  xDT <- branchingDT[branch_pocket == i]

  p1 <- ggplot(xDT, aes(centroid_x, centroid_y)) +
    theme_classic() +
    geom_point(size = 0.5, color = .flowColours(xDT$centroid_x, xDT$centroid_y)) +
    coord_fixed() +
    viridis::scale_fill_viridis() +
    plotThemeDark(angle = 0) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      legend.position = "none"
    )
  
  print(p1)
  
  # ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_branching_", i, ".png")), height = 5, width = 8)
  ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_pocket_", i, ".png")), height = 5, width = 8)
}
```

```{r fig_region_stroma, fig.height=2, fig.width=3}
# now .. join spatial to distance of stroma in invasive region
stromaDT <- spatialDT %>%
  group_by(from) %>%
  summarise(neighbours = n()) %>%
  left_join(popStroma[, c("label", "stroma.dist", "stroma.contact", "pop", "centroid_x", "centroid_y")],
            by = c("from" = "label"))

stromaSummary <- stromaDT %>%
  group_by(neighbours, stroma.contact) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n) * 100) %>%
  dplyr::filter(stroma.contact == TRUE)

ggplot(stromaSummary, aes(neighbours, freq)) +
  theme_classic() +
  ylim(0, 100) +
  geom_col(fill = "black") +
  # geom_boxplot() +
  scale_fill_brewer(palette = "Set1") +
  theme(
    # axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    legend.title = element_blank(),
    legend.position = "bottom",
    legend.justification = "left"
  ) +
  xlab("Cell density (#)") + ylab("Stroma contact (%)") +
  ylim(0, 60)
  # coord_flip()

ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_branching_bars.pdf")),
       height = 2, width = 4)
```

```{r fig_branching, fig.height=8, fig.width=13}
ggplot(stromaDT, aes(centroid_x, centroid_y, color = neighbours)) +
  theme_classic() +
  geom_point(size = 0.5) +
  coord_fixed() +
  geom_point() +
  viridis::scale_colour_viridis(option = "inferno") +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

# ggsave(file.path(anaDir, 'clusters', 'aSf5Rr_neighbors.png'), height = 10, width = 15)
```

```{r fig_branching, fig.height=8, fig.width=13}
tumourClusters <- c("0", "9", "22", "23", "24")

limMax <- quantile(popDT[clusters %in% tumourClusters]$stroma.dist, probs = 0.999)[[1]]
limMin <- quantile(popDT[clusters %in% tumourClusters]$stroma.dist, probs = 0.001)[[1]]

x <- popDT[clusters %in% tumourClusters]
y <- popDT[!clusters %in% tumourClusters]
  
ggplot(popDT, aes(centroid_x, centroid_y)) +
  theme_classic() +
  geom_point(size = 0.5) +
  coord_fixed() +
  geom_point(data = y, size = 1, color = "#5B5B5B") +
  geom_point(data = x, size = 1, aes(color = stroma.dist)) +
  viridis::scale_colour_viridis(limits = c(limMin, limMax), option = "inferno") +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

# ggsave(file.path(anaDir, 'clusters', 'aSf5Rr_stroma_dist.png'), height = 10, width = 15)
```

```{r fig_stroma_ki67, fig.height=1, fig.width=1}
# can you show the distance of Ki67+ to stroma in contrast to other tumour?
xDT <- popDT[clusters %in% tumourClusters]
xDT[, is.prolif := FALSE]
xDT[clusters == "9", is.prolif := TRUE]

ggplot(xDT, aes(is.prolif, stroma.dist)) +
  theme_classic() +
  # geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  geom_jitter(width = 0.3, alpha = 1.0) +
  geom_boxplot(outlier.alpha = 0) 
```

```{r}
# can you cluster on numbers, freq and properties?
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "dpLvQE", versionID = versionID, initReactivity = FALSE # Set
)

# run task
funParams <- list(
  uIDs = c("aSf5Rr"),
  popType = c("branch"),
  pops = c("stroma.branch"),
  objectMeasures = c(
    # c("branch-distance", "euclidean-distance")
  ),
  includeCounts = FALSE,
  includeTotalCount = TRUE,
  colName = "default",
  valueName = "stroma.branch",
  excludeSelfConnections = FALSE,
  useClusters = FALSE,
  expandPops = TRUE,
  numClusters = 3
)

task <- cciaObj$runTask(
  funName = "clustRegions.kmeansClust",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# show regions of stroma
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

regionDT <- cciaObj$popDT(
  "region", includeFiltered = TRUE, completeDT = TRUE,
  completeValueNames = "stroma.branch", pops = c("root"))

# popDT <- cciaObj$popDT(
#   "clust", includeFiltered = TRUE, completeDT = TRUE,
#   popCols = c("pop", paste0("stroma.branch_type_", seq(0, 3))),
#   # pops = unlist(unname(cciaObj$popPaths("clust", includeFiltered = TRUE))),
#   pops = unlist(unname(cciaObj$popPaths("clust", includeFiltered = TRUE, includeRoot = TRUE))),
#   forceReload = TRUE)
```

```{r fig_branching_regions, fig.height=5, fig.width=8}
# plot out
ggplot(regionDT, aes(centroid_x, centroid_y, color = as.factor(regions))) +
  theme_classic() +
  plotThemeDark(angle = 0) +
  geom_point(size = 1, alpha = 0.2) +
  coord_fixed() +
  scale_color_brewer(palette = "Set1") +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    # legend.position = "none"
  )

# ggsave(file.path(anaDir, 'clusters', 'aSf5Rr_branching_regions.png'), height = 20, width = 20)
```

```{r fig_regions_heat, fig.height=5, fig.width=13}
# show heatplots
for (i in unique(regionDT$regions)) {
  xDT <- regionDT[regions == i]

  p1 <- ggplot(xDT, aes(centroid_x, centroid_y)) +
    theme_classic() +
    geom_point(size = 0.5, color = .flowColours(xDT$centroid_x, xDT$centroid_y)) +
    coord_fixed() +
    # viridis::scale_colour_viridis(limits = c(0, limY)) +
    plotThemeDark(angle = 0) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      legend.position = "none"
    )
  
  print(p1)
  
  ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_region_pockets_", i, ".png")), height = 5, width = 8)
}
```

```{r fig_regions_heat, fig.height=1.5, fig.width=2}
regionSummary <- regionDT %>% pivot_longer(
  cols = c(
    "stroma.branch/zero", "stroma.branch/three",
    "stroma.branch/one", "stroma.branch/two",
    # "sum", "branch-distance", "euclidean-distance"
    # "branch-distance", "euclidean-distance"
  ),
  names_to = "measure",
  values_to = "value"
) %>%
  group_by(measure, regions) %>%
  summarise(mean = mean(value, rm.na = TRUE)) %>%
  mutate(norm = (mean - min(mean))/(max(mean) - min(mean))) %>%
  replace_na(list(norm = 0))

ggplot(regionSummary, aes(regions, measure)) +
    theme_classic() +
    # geom_tile(aes(fill = mean), colour = "white", size = 0.5) +
    geom_tile(aes(fill = norm), colour = "white", size = 0.5) +
    viridis::scale_fill_viridis(
      breaks = c(0, 1),
      labels = c(0, 1)
    ) +
    theme(
      legend.position = "none",
      legend.title = element_blank(),
      legend.text = element_text(size = 20),
      legend.key.size = unit(10, "mm"),
      axis.text.y = element_text(size = 20),
      axis.text.x = element_text(size = 20),
      # axis.text.x = element_text(size = 20, angle = 45, hjust = 1, vjust = 1),
      strip.background = element_blank(),
      strip.text.x = element_blank()
      ) +
    xlab("") + ylab("")
```

```{r}
# find nearest neighbours
popNN <- dbscan::kNN(
  as.matrix(regionDT[, c('centroid_y', 'centroid_x')]),
  k = 1,
  query = as.matrix(popDT[, c('centroid_y', 'centroid_x')]))

# filter long distances
regionVals <- regionDT[popNN$id, ]$regions
# regionVals <- regionDT[popNN$id, ]$`branch-type`
regionVals[popNN$dist > 100 * cciaObj$omeXMLPixelRes()$x] <- -1

# assign regions to pops
popDT[, regionsNN := as.factor(regionVals)]
```

```{r fig_pop_branching, fig.height=3, fig.width=2.5}
summaryDT <- popDT %>%
  dplyr::filter(clusters != "2") %>%
  # drop_na() %>%
  # group_by(pop, regionsNN) %>%
  group_by(clusters, regionsNN) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n) * 100) %>%
  dplyr::filter(regionsNN != "-1")
  
# summaryDT$clusters <- recode(
#   summaryDT$clusters,
#   `0` = 'CD20+ B cell',
#   `1` = 'CD8+ T cell',
#   `2` = 'CD54+ 1',
#   `3` = 'Unspecified',
#   `4` = 'CD163+ Macro',
#   `5` = 'CD45+1',
#   `6` = 'CD4+ T cell',
#   `7` = 'CD54+ 2',
#   `8` = 'CD45+ 2',
#   `9` = 'CD54+ 3',
#   `10` = 'CD11c+ Macro',
#   `11` = 'CD15+ Macro',
#   `12` = 'CD54+ 4',
#   `13` = 'CD61+',
#   `14` = 'CD31+',
#   `15` = 'CD54+ 5',
#   `16` = 'Glyco.A+'
# )
# summaryDT$regionsNN <- recode(
#   summaryDT$regionsNN,
#   `1` = 'Loose',
#   `2` = 'Medium',
#   `3` = 'Dense'
# )

# ggplot(summaryDT, aes(pop, freq, fill = regionsNN)) +
# ggplot(summaryDT, aes(clusters, freq, fill = regionsNN)) +
ggplot(summaryDT, aes(reorder(clusters, freq), freq, fill = regionsNN)) +
  theme_classic() +
  # ylim(0, 100) +
  geom_col() +
  scale_fill_brewer(palette = "Set1") +
  theme(
    # axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    legend.title = element_blank(),
    legend.position = "bottom",
    legend.justification = "left"
  ) +
  xlab("") + ylab("Stroma region (%)") +
  coord_flip()
```

```{r}
# get populations and show maps
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE
)

# get label properties
labelDT <- as.data.table(cciaObj$labelProps("stroma")$as_df())
```

```{r}
# summaryDT <- labelDT %>% pivot_longer(
#   cols = c(
#     "eccentricity", "orientation", "extent", "solidity", "oblate",
#     "prolate", "aspect_ratio", "fill", "solidity"),
#   names_to = "measure",
#   values_to = "value"
# )
```

```{r fig_stroma, fig.height=5, fig.width=8}
# filter 
summaryDT <- labelDT[eccentricity > quantile(labelDT$eccentricity, probs = 0.05)[[1]]]

# plot shape of stroma
for (x in c("eccentricity", "orientation", "extent", "solidity", "oblate",
            "prolate", "aspect_ratio", "fill", "solidity", "aspect_ratio",
            "feret_diameter_max", "equivalent_diameter", "perimeter_to_area")) {
  limY <- quantile(summaryDT[[x]], probs = 0.98)[[1]]
  
  p1 <- ggplot(summaryDT, aes(centroid_x, centroid_y, color = get(x))) +
    theme_classic() +
    plotThemeDark(angle = 0) +
    geom_point(size = 0.5) +
    coord_fixed() +
    viridis::scale_colour_viridis(limits = c(0, limY)) +
    ggtitle(x) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      legend.position = "none"
    )
  
  print(p1)
}
```

