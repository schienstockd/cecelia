---
title: "Run modules"
output: html_document
date: '2022-08-16'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Examples to run functions and modules

```{r}
Sys.setenv(KMP_DUPLICATE_LIB_OK = "TRUE")

# set test variables
pID <- "5g6H4F"
versionID <- 1
projectsDir <- "/Volumes/USER_data/Dominik/CECELIA_BACKUP/"
hpcDir <- "/data/scratch/projects/punim1124/cecelia/USERS/schienstockd/"
```

```{r}
anaDir <- "/Volumes/USER_data/Dominik/Experiments/stomics/10x/ANALYSIS"
```

```{r}
# Load cluster data
devtools::load_all("../")
cciaUse("~/cecelia/dev")

library(ggplot2)
library(tidyverse)
```

```{r}
# HPC config
HPC_CONF <-  list(
  hpc = list(
    conf = list(
      email = "schienstockd@student.unimelb.edu.au",
      emailOnBegin = FALSE,
      emailOnEnd = FALSE,
      emailOnFail = TRUE,
      numNodes = 1,
      numTasks = 1,
      numCPUperTask = 1,
      numGPUperTask = 1,
      memory = 50,
      walltime = "00-12:00:00",
      # walltime = "00-01:00:00",
      # walltime = "00-00:30:00",
      # walltime = "02-00:00:00",
      # projectPartitions = "physical",
      # projectID = "punim1124",
      # useGPU = FALSE
      projectPartitions = "gpu-a100",
      projectID = "punim1031",
      useGPU = TRUE
    )
  ),
  utils = list(
    ssh = list(
      username = "schienstockd",
      address = "spartan.hpc.unimelb.edu.au",
      keyfile = "/Users/Dominik/.ssh/spartan_rsa"
    ),
    python = list(
      condaEnv = cciaConf()$python$conda$source$env
    )
  )
)
```

```{r}
# a <- readRDS("~/R-workspace/cecelia/inst/app/shiny_bookmarks/ba9d364da69c2674/values.rds")
# a$project$ProjectUID <- "RTA7nu"
# a$project$ProjectPath <- "/Volumes/USER_data/Dominik/CECELIA_BACKUP/RTA7nu"
# a$project$ProjectName <- "YA CCL19-DTR"
# saveRDS(a, "~/R-workspace/cecelia/inst/app/shiny_bookmarks/ba9d364da69c2674/values.rds")
```

```{r}
# a <- readRDS("~/R-workspace/cecelia/inst/app/shiny_bookmarks/ba9d364da69c2674/input.rds")
# a
```


```{r}
# upload STOMICS
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run task
funParams <- list(
  sumValue = 1,
  filterValue = 1,
  minFilterValue = 0
)

# run task
task <- cciaObj$runTask(
  funName = "importImages.tenxXenium",
  funParams = funParams,
  envVars = HPC_CONF,
  hpcDir = paste(hpcDir, pID, "ANALYSIS", sep = "/"),
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# upload STOMICS
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run cellpose
# run task
funParams <- list(
)

# run task
task <- cciaObj$runTask(
  funName = "hpc.uploadCciaObj",
  funParams = funParams,
  envVars = HPC_CONF,
  hpcDir = paste(hpcDir, pID, "ANALYSIS", sep = "/"),
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```


```{r}
genes <- list(
  tumour_general = c("ABCC11", "AGR3", "DSP", "ERBB2", "FOXA1",
                     "GATA3", "S100A14", "SERPINA3", "TACSTD2"),
  tumour_dcis = c("AGR3", "CEACAM6", "MZB1", "SERPINA3"),
  tumour_invasive = c("FASN"),
  proliferative = c("MKI67", "TOP2A"),
  myoepithelium_1 = c("ACTA2", "DST", "KRT14", "KRT5", "MYLK"),
  myoepithelium_2 = c("KRT15", "KRT23", "PTN", "SFRP1"),
  stroma = c("ALDH1A3", "GJB2", "LUM", "MMP2", "POSTN", "SFRP4"),
  endothelial = c("AQP1", "EGFL7", "PECAM1", "VWF"),
  b_cells = c("BANK1", "CD79A", "MS4A1"),
  t_cells = c("CCL5", "CD4", "CD8A", "CXCR4", "CYTIP",
              "IL7R", "LTB", "TRAC"),
  macrophages = c("APOC1", "C15orf48", "C1QA", "C1QC", "CD14", "CD163",
                  "CD68", "FGL2", "ITGAX", "MMP12"),
  dendritic_cells = c("CCR7", "CD83", "IL3RA", "LILRA4", "PLD4"),
  mast_cells = c("CPA3", "CTSG", "KIT")
)
```

```{r}
# upload STOMICS
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run cellpose
# run task
funParams <- list(
  valueName = "default",
  # valueName = "stroma",
  models = list(
    # "1" = list(
    #   "model" = "ccia.fluo",
    #   # "model" = "cyto2",
    #   "matchAs" = "none",
    #   "cellDiameter" = 10,
    #   "cellChannels" = list("ALDH1A3", "GJB2", "LUM", "MMP2", "POSTN", "SFRP4"),
    #   "nucChannels" = list(),
    #   "normalise" = 98,
    #   "stitchThreshold" = 0.2,
    #   # "mergeLabels" = FALSE,
    #   "mergeLabels" = TRUE,
    #   "threshold" = 0,
    #   "relTreshold" = 0,
    #   "gaussianFilter" = 4,
    #   "sumFilter" = 0,
    #   "medianFilter" = 0
    # )
    # "1" = list(
    #   "model" = "cyto2",
    #   "matchAs" = "cyto",
    #   # "matchAs" = "none",
    #   "cellDiameter" = 10,
    #   "cellChannels" = list(
    #     "APOC1", "C15orf48", "C1QA", "C1QC", "CD14",
    #     "CD163", "CD68", "FGL2", "ITGAX", "MMP12",
    #     "CCR7", "CD83", "IL3RA", "LILRA4", "PLD4",
    #     "BANK1", "CD79A", "MS4A1", "CCL5", "CD4",
    #     "CD8A", "CXCR4", "CYTIP", "LTB", "TRAC"),
    #   "nucChannels" = list("Hoechst"),
    #   "normalise" = 99,
    #   "stitchThreshold" = 0.2,
    #   "mergeLabels" = FALSE,
    #   "threshold" = 1,
    #   "relTreshold" = 0,
    #   "gaussianFilter" = 0,
    #   "medianFilter" = 0
    # ),
    "1" = list(
      "model" = "cyto2",
      # "matchAs" = "nuc",
      "matchAs" = "none",
      "cellDiameter" = 10,
      "cellChannels" = list("Hoechst"),
      "nucChannels" = list(),
      "normalise" = 99.8,
      "stitchThreshold" = 0.2,
      "mergeLabels" = FALSE,
      "threshold" = 0,
      "relTreshold" = 0,
      "gaussianFilter" = 0,
      "medianFilter" = 0
    )
  ),
  clearDepth = FALSE,
  clearTouchingBorder = FALSE,
  # haloSize = 0,
  # haloWholeCell = FALSE,
  haloSize = 20, # for nuclei expansion
  haloWholeCell = TRUE,
  blockSize = 2048,
  # blockSize = 512,
  overlap = 100, # for larger structures
  context = 40,
  # overlap = 64,
  # context = 52,
  blockSizeZ = -1,
  overlapZ = -1,
  segment = TRUE,
  # segment = FALSE,
  measure = TRUE,
  # measure = FALSE,
  updateMeasures = FALSE,
  # extendedMeasures = TRUE,
  extendedMeasures = FALSE,
  saveMeshes = FALSE,
  saveMeasures = TRUE,
  labelExpansion = 0,
  labelErosion = 0,
  minCellSize = 50,
  matchThreshold = 0.2,
  removeUnmatched = TRUE,
  labelOverlap = 0.2
  # labelOverlap = 0
)

# run task
task <- cciaObj$runTask(
  funName = "segment.cellpose",
  funParams = funParams,
  envVars = HPC_CONF,
  hpcDir = paste(hpcDir, pID, "ANALYSIS", sep = "/"),
  env = "hpc",
  # env = "local",
  runInplace = FALSE,
  # runInplace = TRUE,
  # taskID = 1
  taskID = 2
)

# task$result(wait = TRUE)
```

```{r}
# retrieve
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE
)

cciaObj$imLabelsFilepath("default")
cciaObj$valueSuffixes("imLabelsFilepath", valueName = "default")

labelsFilepath <- "default.zarr"
attr(labelsFilepath, "suffixes") <- c("halo")
cciaObj$setImLabelsFilepath(labelsFilepath, valueName = "default")
cciaObj$imLabelsFilepath("default")

channelNames <- cciaObj$imChannelNames()
attr(channelNames, "types") <- c("halo")
cciaObj$setImChannelNames(channelNames, valueName = "default")

unique(unlist(lapply(
        c("default"),
        function(x) cciaObj$valueSuffixes("imLabelsFilepath", valueName = x))))
cciaObj$saveState()
```


```{r}
# retrieve 
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run cellpose
# run task
funParams <- list(
  # valueNames = c("default", "stroma"),
  # valueNames = c("stroma"),
  valueNames = c("default"),
  retrieveMeshesOnly = FALSE
)

# run task
task <- cciaObj$runTask(
  funName = "segment.retrieve",
  funParams = funParams,
  envVars = HPC_CONF,
  hpcDir = paste(hpcDir, pID, "ANALYSIS", sep = "/"),
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# upload STOMICS
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run cellpose
# run task
funParams <- list(
)

# run task
task <- cciaObj$runTask(
  funName = "hpc.retrieveCciaObj",
  funParams = funParams,
  envVars = HPC_CONF,
  hpcDir = paste(hpcDir, pID, "ANALYSIS", sep = "/"),
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# run population clustering
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE
)

pops <- cciaObj$popPaths(popType = "clust", includeFiltered = TRUE)
pops <- pops[!pops %in% c("DCIS", "invasive")]
pops <- c("root")

#popDT.labels <- cciaObj$popDT("labels", pops = c("default"))
popDT.clust <- cciaObj$popDT("clust", pops = pops, includeFiltered = TRUE)

# DT <- cciaObj$labelProps()$as_df()

# a <- popDT.labels[label %in% c(31572, 31579)]
#b <- popDT.clust[clusters %in% c(5)]

# write.csv(popDT.labels, file.path(anaDir, "pop.csv"))
# write.csv(DT, file.path(anaDir, "pop.csv"))
```

```{r}
props <- read.csv("~/Downloads/halo.csv", sep = "\t")
```


```{r}
# upload STOMICS
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run task
funParams <- list(
  specialType = "tenxXenium",
  isSequence = FALSE
)

task <- cciaObj$runTask(
  funName = "importImages.upload",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# import STOMICS
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

# run task
funParams <- list(
  filterValue = 4
)

task <- cciaObj$runTask(
  funName = "importImages.tenxXenium",
  funParams = funParams,
  env = "hpc",
  runInplace = FALSE,
  taskID = 1
)
```

```{r}
# run population clustering
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "dpLvQE", versionID = versionID, initReactivity = FALSE
)

uIDs <- c("aSf5Rr")

# run task
funParams <- list(
  popType = "flow",
  popsToCluster = c(),
  savePops = FALSE,
  keepPops = FALSE,
  resolution = 0.1,
  mergeUmap = FALSE,
  normalisePercentile = 99.8,
  normalisePercentileBottom = 0,
  normaliseAxis = "channels",
  normaliseToMedian = FALSE,
  normaliseIndividually = FALSE,
  # transformation = "log",
  transformation = "NONE",
  logBase = 0,
  valueName = "default",
  uIDs = uIDs,
  clusterChannels = list(
    base = list(
      channels = c(0)
    )
  ),
  objectMeasures = c("area", "perimeter")
)

task <- cciaObj$runTask(
  funName = "clustPopulations.leidenClustering",
  funParams = funParams,
  env = "local",
  # runInplace = TRUE,
  runInplace = FALSE,
  taskID = 1
)
```

```{r}
# run population clustering
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "dpLvQE", versionID = versionID, initReactivity = FALSE
)

# a <- cciaObj$cciaObjects()[[1]]$popDT("labels")

allChannelNames <- cciaObj$cciaObjects()[[1]]$imChannelNames()
# channelNames <- unname(allChannelNames[allChannelNames != "Hoechst"])

# get tumour and non-tumour first
# Then, use the rest of the genes to get a more detailed
# cluster map and try to make regions to see whether there are specific interactions
# in specific regions for these tumours
# Then, can you match that with the stroma branching?
geneGroups <- c("tumour", "myoepithelium", "endothelial")

# channelNames <- unique(unlist(unname(genes[grepl(
# for all other genes
channelNames <- unique(unlist(unname(genes[!grepl(
  paste0(geneGroups, collapse = "|"), names(genes))])))
channelNames <- channelNames[channelNames != "Hoechst"]

# get numbers
channelNames <- sapply(
  channelNames, function(x) {
    unname(which(allChannelNames == x)) - 1
  }, USE.NAMES = FALSE
)

uIDs <- c("aSf5Rr")

# Can you try to get tumour cells and others
# Then, make regions and see whether there are different
# cellular make ups in invasive and DCIS
# ie/ this section could be after IMC to show
# sequential Leiden clustering

# run task
funParams <- list(
  # popType = "flow",
  popType = "clust",
  # popsToCluster = c(),
  popsToCluster = c("others"),
  savePops = TRUE,
  # savePops = FALSE,
  keepPops = TRUE,
  # keepPops = FALSE,
  resolution = 1.0,
  # resolution = 0.4,
  mergeUmap = TRUE,
  # mergeUmap = FALSE,
  normalisePercentile = 99.8,
  normalisePercentileBottom = 0,
  normaliseAxis = "channels",
  normaliseToMedian = FALSE,
  normaliseIndividually = FALSE,
  # transformation = "log",
  transformation = "NONE",
  logBase = 0,
  valueName = "default",
  uIDs = uIDs,
  clusterChannels = list(
    halo = list(
      channels = channelNames
    )
    # base = list(
    #   channels = channelNames
    # )
  ),
  objectMeasures = c(
    "area", "perimeter", "solidity",
    "oblate", "prolate", "extent",
    "fill", "eccentricity"
  )
)

task <- cciaObj$runTask(
  funName = "clustPopulations.leidenClustering",
  funParams = funParams,
  env = "local",
  # runInplace = TRUE,
  runInplace = FALSE,
  taskID = 1
)

task$result(wait = TRUE)
```

```{r}
# get branching of stroma network
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

popDT <- cciaObj$popDT(
  "clust", includeFiltered = TRUE, completeDT = TRUE,
  # pops = unlist(unname(cciaObj$popPaths("clust", includeFiltered = TRUE))),
  pops = unlist(unname(cciaObj$popPaths("clust", includeFiltered = TRUE, includeRoot = TRUE))),
  forceReload = TRUE)

branchDT <- cciaObj$popDT(
  "branch", includeFiltered = TRUE, completeDT = TRUE,
  completeValueNames = "stroma.branch",
  pops = unlist(unname(cciaObj$popPaths("branch", includeFiltered = TRUE, includeRoot = FALSE))))

regionDT <- cciaObj$popDT(
  "region", includeFiltered = TRUE, completeDT = TRUE,
  completeValueNames = "default",
  pops = unlist(unname(cciaObj$popPaths("region", includeFiltered = TRUE, includeRoot = FALSE))))
```

```{r}
# find closest branching to region
x <- as.matrix(branchDT[`branch-type` < 3, c('centroid_y', 'centroid_x')])
rownames(x) <- branchDT[`branch-type` < 3]$label

# find nearest neighbours
popNN <- dbscan::kNN(
  x, k = 1, query = as.matrix(regionDT[, c('centroid_y', 'centroid_x')]))

# filter long distances
# regionVals <- regionDT[popNN$id, ]$regions
# regionVals <- branchDT[popNN$id, ]$`branch-type`
regionDT[, branch.id := popNN$id]
regionDT[, branch.dist := popNN$dist]
regionDT[branchDT[, c("label", "branch-type")], on = c("branch.id" = "label"),
      `branch-type` := `branch-type`]
```


```{r fig_pop_branching, fig.height=4, fig.width=4}
summaryDT <- copy(regionDT)
# threshold branching
summaryDT[branch.dist > (12 / cciaObj$omeXMLPixelRes()$x), `branch-type` := -1]

summaryDT <- summaryDT %>%
  # drop_na() %>%
  # group_by(pop, regionsNN) %>%
  group_by(pop, `branch-type`) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n) * 100) %>%
  dplyr::filter(`branch-type` != "-1")
  
summaryDT$`branch-type` <- recode(
  summaryDT$`branch-type`,
  `0` = 'Loose',
  `1` = 'Medium',
  `2` = 'Dense'
)
summaryDT$`branch-type` <- factor(
  summaryDT$`branch-type`, levels = c("Loose", "Medium", "Dense"))

# ggplot(summaryDT, aes(pop, freq, fill = regionsNN)) +
# ggplot(summaryDT, aes(clusters, freq, fill = regionsNN)) +
ggplot(summaryDT %>% drop_na(), aes(reorder(pop, freq), freq, fill = `branch-type`)) +
  theme_classic() +
  ylim(0, 100) +
  geom_col() +
  scale_fill_brewer(palette = "Set1") +
  theme(
    # axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    legend.title = element_blank(),
    legend.position = "bottom",
    legend.justification = "left"
  ) +
  xlab("") + ylab("Stroma contact (%)") +
  coord_flip()

# ggsave(file.path(anaDir, 'stroma', 'aSf5Rr_branching_and_regions.png'), plot = p1, height = 4, width = 4)
# ggsave(file.path(anaDir, 'stroma', 'aSf5Rr_branching_and_regions.png'), height = 4, width = 4)

write.csv(summaryDT, file.path(anaDir, "aSf5Rr", "stroma_and_regions.csv"))
```


```{r}
# create populations for branching
popType <- "clust"
valueName <- "default"

# add children
pops <- list(
  "invasive" = list(
    filterMeasure = "clusters",
    filterValues = "0",
    filterFun = "eq"
  )
)
parentPops <- "root"

# remove populations
cciaObj$delPopsByPath(
  popType,
  pops = levels(interaction(parentPops, names(pops), sep = "/")),
  includeFiltered = TRUE
)

# add populations
cciaObj$addFilteredPops(popType, parentPops, pops, valueName = valueName)

# save to disk
cciaObj$savePops(popType, purge = TRUE, includeFiltered = TRUE)

# save object
# cciaObj$saveState()
```

```{r}
# run population clustering
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "dpLvQE", versionID = versionID, initReactivity = FALSE
)

allChannelNames <- cciaObj$cciaObjects()[[1]]$imChannelNames()
channelNames <- unname(allChannelNames[allChannelNames != "Hoechst"])

# get numbers
channelNames <- sapply(
  channelNames, function(x) {
    unname(which(allChannelNames == x)) - 1
  }, USE.NAMES = FALSE
)

uIDs <- c("aSf5Rr")

# run task
funParams <- list(
  popType = "clust",
  popsToCluster = c("invasive"),
  # savePops = TRUE,
  savePops = FALSE,
  keepPops = TRUE,
  # keepPops = FALSE,
  resolution = 0.4,
  mergeUmap = TRUE,
  normalisePercentile = 99.8,
  normalisePercentileBottom = 0,
  normaliseAxis = "channels",
  normaliseToMedian = FALSE,
  normaliseIndividually = FALSE,
  # transformation = "log",
  transformation = "NONE",
  logBase = 0,
  valueName = "default",
  uIDs = uIDs,
  clusterChannels = list(
    # halo = list(
    #   channels = channelNames
    # ),
    base = list(
      channels = channelNames
    )
  ),
  objectMeasures = c(
    "area", "perimeter", "solidity",
    "oblate", "prolate", "extent",
    "fill", "eccentricity"
  )
)

task <- cciaObj$runTask(
  funName = "clustPopulations.leidenClustering",
  funParams = funParams,
  env = "local",
  # runInplace = TRUE,
  runInplace = FALSE,
  taskID = 1
)
```

```{r}
# plot out where the clusters are
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE
)

# get pops
popDT <- cciaObj$popDT(
  # popType = "clust", includeFiltered = TRUE, includeX = FALSE, completeDT = TRUE)
  popType = "flow")
  # popCols = c("label", "clusters", "UMAP_1", "UMAP_2"))
```

```{r fig_clust_spatial, fig.height=5, fig.width=13}
# plot out
for (i in unique(popDT$clusters)) {
  x <- popDT[clusters == i]
  y <- popDT[clusters != i]

  p1 <- ggplot(y, aes(centroid_x, centroid_y)) +
    theme_classic() +
    geom_point(data = y, size = 1, color = "#5B5B5B") +
    # geom_point(data = x, size = 1, color = "#FFCD2E") +
    geom_point(data = x, size = 1, color = .flowColours(x$centroid_x, x$centroid_y)) +
    coord_fixed() +
    plotThemeDark(angle = 0) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      legend.position = "none"
    )
  
  print(p1)
  
  ggsave(file.path(anaDir, "clusters", "indv", paste0("aSf5Rr_cluster_", i, ".png")), height = 10, width = 13)
}
```

```{r fig_clust_spatial, fig.height=8, fig.width=13}
# plot out
# x.ki67 <- popDT[pop == "invasive.KI67"]
x.ki67 <- popDT[pop %in% c("invasive", "invasive.KI67")]
x.branching <- unique(popStroma %>%
  dplyr::filter(
    startsWith(pop, "invasive"),
    # `branch-type` > 0
    ) %>%
  select(stroma.centroid_x, stroma.centroid_y))
y <- popDT[!clusters %in% tumourClusters]

ggplot(popDT, aes(centroid_x, centroid_y)) +
  theme_classic() +
  geom_point(data = y, size = 1, color = "#5B5B5B") +
  geom_point(data = x.ki67, size = 4, color = .flowColours(
    x.ki67$centroid_x, x.ki67$centroid_y,
    # colramp = colorRampPalette(rev(RColorBrewer::brewer.pal(9, "Purples")))
    colramp = colorRampPalette(viridisLite::viridis(n = 8))
    )) +
  geom_point(data = x.branching, size = 3, aes(stroma.centroid_x, stroma.centroid_y),
             shape = 21, stroke = 0.5,
             fill = .flowColours(
    x.branching$stroma.centroid_x, x.branching$stroma.centroid_y
    # colramp = colorRampPalette(RColorBrewer::brewer.pal(6, "Greens"))
    )) +
  coord_fixed() +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

# ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_tumour.png")), height = 10, width = 13)
ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_invasive_branching.png")), height = 10, width = 13)
```

```{r fig_clust_spatial, fig.height=5, fig.width=13}
# plot out
limY <- quantile(popDT$MKI67, probs = 0.99)[[1]]

ggplot(popDT, aes(centroid_x, centroid_y, z = MKI67)) +
  theme_classic() +
  stat_summary_2d(bins = 128) +
  viridis::scale_fill_viridis(limits = c(0, limY)) +
  coord_fixed() +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

ggsave(file.path(anaDir, "clusters", "markers", paste0("aSf5Rr_markers_MKI67.png")), height = 10, width = 13)
```

```{r}
excludeCols <- c("label", "clusters", "pop", "UMAP_1", "UMAP_2", "centroid_x", "centroid_y")
colsToShow <- colnames(popDT)[!colnames(popDT) %in% excludeCols]

# show heatmap
markersToPlot <- popDT %>%
  pivot_longer(
    cols = all_of(colsToShow), names_to = "marker", values_to = "value"
    )
markersToPlot$marker <- as.factor(markersToPlot$marker)

# show heatmap for clusters
markersSummary <- markersToPlot %>%
  drop_na() %>%
  group_by(marker, clusters) %>%
  summarise(mean = mean(value, rm.na = TRUE)) %>%
  mutate(norm = (mean - min(mean))/(max(mean) - min(mean))) %>%
  replace_na(list(norm = 0))

# find order for clusters and markers
markersMatrix <- markersSummary %>%
  pivot_wider(names_from = marker, values_from = norm, id_cols = "clusters")

hcClusters <- hclust(dist(as.matrix(markersMatrix %>% dplyr::select(-clusters))), "ave")
hcMarkers <- hclust(dist(t(as.matrix(markersMatrix %>% dplyr::select(-clusters)))), "ave")

clustersOrder <- markersMatrix$clusters[hcClusters$order]
markerOrder <- colnames(markersMatrix)[2:length(colnames(markersMatrix))][hcMarkers$order]

markersSummary <- markersSummary %>%
  mutate(
    clusters = factor(clusters, levels = sort(as.numeric(levels(clustersOrder)))),
    marker = factor(marker, levels = markerOrder)
  )
```


```{r fig_heat, fig.height=20, fig.width=20}
p1 <- ggplot(markersSummary, aes(clusters, marker)) +
  theme_classic() +
  # geom_tile(aes(fill = mean), colour = "white", size = 0.5) +
  geom_tile(aes(fill = norm), colour = "white", size = 0.5) +
  viridis::scale_fill_viridis(
    breaks = c(0, 1),
    labels = c(0, 1)
  ) +
  theme(
    legend.position = "none",
    legend.title = element_blank(),
    legend.text = element_text(size = 20),
    legend.key.size = unit(10, "mm"),
    # axis.text.y = element_text(size = 20),
    # axis.text.x = element_text(size = 20),
    axis.text.x = element_text(size = 10, angle = 90, hjust = 1, vjust = 1),
    strip.background = element_blank(),
    strip.text.x = element_blank()
    ) +
  xlab("") + ylab("") +
  coord_flip()

# ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_heat.pdf")), height = 49, width = 8)
ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_heat.pdf")), plot = p1, height = 8, width = 49)
```

```{r}
# define populations
popMap <- list(
  "Malignant.ESR-" = c("0", "4"),
  "Malignant.ESR+" = c("3"),
  "Malignant.KI67+" = c("9"),
  "FoxP3+ T cells" = c("1"),
  "Stroma" = c("2"),
  # "Malignant.ESRlo" = c("4"),
  "CD86+ Macro" = c("5"),
  "Undefined" = c("6"),
  "CD8+ T cells" = c("7"),
  "CLEC14A+" = c("8")
)
```

```{r fig_clust_spatial_pops, fig.height=5, fig.width=13}
popDT$clusters.pop <- "NONE"

for (i in names(popMap)) {
  for (y in popMap[[i]])
    popDT[clusters == y, clusters.pop := i]
}

# plot out
p1 <- ggplot(popDT[clusters.pop %in% c(
  "Malignant.ESR-", "Malignant.ESR+", "Malignant.KI67+", "FoxP3+ T cells",
  "Macro", "CD8+ T cells", "CD86+ Macro"
)], aes(centroid_x, centroid_y, color = clusters.pop)) +
  scale_color_brewer(name = NULL, palette = "Set1") +
  theme_classic() +
  geom_point(size = 0.2) +
  coord_fixed() +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank(),
    legend.key.size = unit(5, "mm"),
    legend.text = element_text(size = 18),
  ) + guides(colour = guide_legend(override.aes = list(size = 4)))
p2 <- p1 + theme(legend.position = "none")
  
ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_pops.png")), plot = p1, height = 10, width = 13)
ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_pops_wo_legend.png")), plot = p2, height = 10, width = 13)
```

```{r fig_pops_umap, fig.height=2, fig.width=2}
library(tidyverse)

# get mean positions of clusters
meanClusterPos <- popDT.clust %>%
  group_by(clusters) %>%
  summarise(
    UMAP_1 = median(UMAP_1),
    UMAP_2 = median (UMAP_2)
  )

clustersPalette <- randomcoloR::distinctColorPalette(
  length(unique(popDT.clust$clusters)))

# plot UMAP with paga connections
p1 <- ggplot(
  popDT.clust,
    # mutate(clusters = factor(clusters, levels = clustersOrder)),
  aes(UMAP_1, UMAP_2)
  ) +
  theme_classic() +
  geom_point(aes(color = as.factor(clusters)), size = 0.5) +
  # scale_color_brewer(name = NULL, palette = "Set1") +
  scale_color_manual(values = clustersPalette) +
  theme(
    axis.text = element_text(size = 15),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.justification = "center",
    legend.direction = "horizontal",
    # legend.position = "bottom",
    legend.position = "none",
    legend.title = element_blank(),
    legend.key.size = unit(5, "mm"),
    legend.text = element_text(size = 18),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
    ) +
  # guides(colour = guide_legend(override.aes = list(size = 4)))
  geom_label(
    data = meanClusterPos,
    aes(label = clusters),
    label.size = 0.25,
    color = "black"
    )

ggsave(file.path(anaDir, "clusters", "aSf5Rr_umap.png"), width = 5, height = 5, plot = p1)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE
)

# run task
funParams <- list(
  valueName = "stroma",
  preDilationSize = 20,
  postDilationSize = 2
)

# run task
task <- cciaObj$runTask(
  funName = "segment.createBranching",
  funParams = funParams,
  env = "local",
  runInplace = FALSE,
  taskID = 1
)
```

```{r}
# get branching of stroma network
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

pops <- unlist(unname(cciaObj$popPaths("branch", includeFiltered = TRUE)))

branchingDT <- cciaObj$popDT("branch", pops = pops, popCols = c("branching-type"),
                             includeFiltered = TRUE)

spatialDT <- cciaObj$spatialDT("default")

clusterMapping <- list(
  DCIS = c(6),
  Invasive = c(7),
  Macs = c(5),
  CD4 = c(3),
  Stroma = c(4),
  Myoepithelium = c(2),
  Endothelial = c(1)
)

regionDT <- .mapClustNames(regionDT, clusterMapping, "regions", removeNone = FALSE)

# merge pops
# spatialDT[popDT[, c("label", "pop")],
# spatialDT[regionDT[, c("label", "regions")],
spatialDT[regionDT[, c("label", "clusters.name")],
          on = c("to" = "label"),
          # pop.to := pop]
          # pop.to := regions]
          pop.to := clusters.name]
# spatialDT[popDT[, c("label", "pop")],
# spatialDT[regionDT[, c("label", "regions")],
spatialDT[regionDT[, c("label", "clusters.name")],
          on = c("from" = "label"),
          # pop.from := pop]
          # pop.from := regions]
          pop.from := clusters.name]

# filter same type associations
spatialDT <- spatialDT[pop.to != pop.from]
```

```{r}
regionDT.spatial <- copy(regionDT)

# then join closest contact if present
regionDT.spatial[
  spatialDT[,
    # [!] this will only select the cells in closest proximity
    .SD[which.min(dist)], by = c("from")][, c("from", "pop.from", "pop.to")],
  on = c("label" = "from"), `:=` (pop.from = pop.from, pop.to = pop.to)
]

regionDT.spatial[is.na(pop.to), pop.to := "NONE"]
regionDT.spatial[is.na(pop.from), pop.from := "NONE"]
```

```{r fig_interactions_heat, fig.height=7, fig.width=7}
# freqInt <- spatialDT %>%
freqInt <- regionDT.spatial %>%
  dplyr::filter(pop.from != "NONE" & pop.to != "NONE") %>%
  mutate(
    pop.from = as.character(pop.from),
    pop.to = as.character(pop.to)
  ) %>%
  group_by(pop.from, pop.to) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n) * 100) %>%
  drop_na() %>%
  ungroup() %>%
  complete(pop.from, pop.to, fill = list(freq = 0))

ggplot(freqInt, aes(as.factor(pop.from), as.factor(pop.to))) +
  theme_classic() +
  geom_tile(aes(fill = freq), colour = "white", size = 0.5) +
  viridis::scale_fill_viridis(
    breaks = c(0, 1),
    labels = c(0, 1)
  ) +
  theme(
    legend.position = "none",
    legend.title = element_blank(),
    legend.text = element_text(size = 20),
    legend.key.size = unit(10, "mm"),
    axis.text.y = element_text(size = 20),
    axis.text.x = element_text(size = 20, angle = 45, hjust = 1, vjust = 1),
    # axis.text.x = element_text(size = 20),
    strip.background = element_blank(),
    strip.text.x = element_blank()
    ) + xlab("") + ylab("")

ggsave(file.path(anaDir, "regions_interaction.pdf"), width = 5, height = 4)
```

```{r fig_interactions, fig.height=2, fig.width=6}
# get "i-niches" and determine a given number of defined clusters
# freqInt <- spatialDT %>%
freqInt <- regionDT.spatial %>%
  group_by(pop.from, pop.to) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n) * 100) %>%
  drop_na() %>%
  ungroup() %>%
  complete(pop.from, pop.to, fill = list(freq = 0))
  # left_join(exp.info)

# show interactions of individuals
for (i in unique(freqInt$pop.from)) {
  x <- freqInt %>% dplyr::filter(pop.from == i) 
  
  p1 <- ggplot(x, aes(as.factor(pop.to), freq)) +
    theme_classic() +
    geom_boxplot(outlier.alpha = 0) +
    geom_jitter(
      # position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
      width = 0.3, alpha = 0.6) +
    # stat_summary(fun=mean, geom="point", size=3, shape=18, color="Magenta") +
    ylab("Population (%)") + xlab("") +
    # ylim(0, 1) +
    scale_fill_brewer(name = NULL, palette = "Set3") +
    ggtitle(i)

  print(p1)
}
```

```{r fig_regions_heat, fig.height=5, fig.width=8}
colsToShow <- colnames(regionDT)
colsToShow <- colsToShow[!colsToShow %in% c("uID", "label", "regions", "pop", "centroid_x", "centroid_y")]
colsToPlot <- regionDT %>%
  pivot_longer(
    cols = all_of(colsToShow), names_to = "col", values_to = "value"
    )
colsToPlot$col <- as.factor(colsToPlot$col)
colsToPlot$value <- as.numeric(colsToPlot$value)

# show heatmap for clusters
colsSummary <- colsToPlot %>%
  drop_na() %>%
  group_by(col, regions) %>%
  # group_by(regions, col) %>%
  summarise(mean = mean(value, rm.na = TRUE)) %>%
  mutate(norm = (mean - min(mean))/(max(mean) - min(mean))) %>%
  replace_na(list(norm = 0))

# find order for clusters and markers
colsMatrix <- colsSummary %>%
  pivot_wider(names_from = col, values_from = norm, id_cols = regions)

hcClusters <- hclust(dist(as.matrix(colsMatrix %>% dplyr::select(-all_of("regions")))), "ave")
hcMarkers <- hclust(dist(t(as.matrix(colsMatrix %>% dplyr::select(-all_of("regions"))))), "ave")

clustersOrder <- colsMatrix[["regions"]][hcClusters$order]
colsOrder <- colnames(colsMatrix)[2:length(colnames(colsMatrix))][hcMarkers$order]

colsSummary[["regions"]] <- factor(colsSummary[["regions"]], levels = clustersOrder)

# show population mapping
unname(sapply(cciaObj$imPopMap("clust", includeFiltered = TRUE), function(x) {
  print(paste(x$path, ": ", paste0(x$filterValues, collapse = ", ")))
}))

p1 <- ggplot(colsSummary %>%
         mutate(
           # clusters = factor(clusters, levels = clustersOrder),
           # clusters = factor(clusters, levels = sort(as.numeric(levels(clustersOrder)))),
           col = factor(col, levels = colsOrder)
         ), aes(col, regions)) +
  theme_classic() +
  # geom_tile(aes(fill = mean), colour = "white", size = 0.5) +
  geom_tile(aes(fill = norm), colour = "white", size = 0.5) +
  viridis::scale_fill_viridis(
    breaks = c(0, 1),
    labels = c(0, 1)
  ) +
  theme(
    legend.position = "none",
    legend.title = element_blank(),
    legend.text = element_text(size = 20),
    legend.key.size = unit(10, "mm"),
    axis.text.y = element_text(size = 20),
    # axis.text.x = element_text(size = 20),
    axis.text.x = element_text(size = 20, angle = 45, hjust = 1, vjust = 1),
    strip.background = element_blank(),
    strip.text.x = element_blank()
    ) +
  xlab("") + ylab("")
plot(p1)

ggsave(file.path(anaDir, "regions_heat.pdf"), width = 9, height = 3)
```

```{r}
# xDT <- branchingDT[`branch-type` > 0]
xDT <- branchingDT

# show distance of tumour to stroma
popNN <- dbscan::kNN(
  as.matrix(xDT[, c('centroid_y', 'centroid_x')]),
  k = 1,
  query = as.matrix(popDT[, c('centroid_y', 'centroid_x')]))

popStroma <- copy(popDT)

# assign dists to pops
popStroma[, stroma.dist := popNN$dist]
popStroma[, stroma.id := popNN$id]
popStroma[, stroma.contact := FALSE]
popStroma[stroma.dist <= 100, stroma.contact := TRUE]

# merge branching info
popStroma[xDT[, c("label", "centroid_x", "centroid_y", "branch-type", "branch-distance")],
      on = c("stroma.id" = "label"),
      `:=` (
        stroma.centroid_x = i.centroid_x,
        stroma.centroid_y = i.centroid_y,
        `branch-type` = `branch-type`,
        `branch-distance` = `branch-distance`
        )]
```

```{r fig_clust_spatial, fig.height=5, fig.width=13}
# plot out
y <- popDT[!clusters %in% tumourClusters]

x <- unique(popStroma %>%
  dplyr::filter(
    startsWith(pop, "invasive")
    # `branch-type` > 0
    ) %>%
  select(stroma.centroid_x, stroma.centroid_y))

ggplot(popDT, aes(centroid_x, centroid_y)) +
  theme_classic() +
  geom_point(data = y, size = 1, color = "#5B5B5B") +
  geom_point(data = x, size = 2,
             aes(stroma.centroid_x, stroma.centroid_y),
             color = .flowColours(x$stroma.centroid_x, x$stroma.centroid_y)) +
  # geom_density_2d_filled(
  #   alpha = 0.5, data = x, aes(stroma.centroid_x, stroma.centroid_y)) +
  # geom_density_2d(
  #   color = "white", size = 1.5,
  #   data = x, aes(stroma.centroid_x, stroma.centroid_y)) +
  # viridis::scale_fill_viridis(option = "inferno", discrete = TRUE) +
  coord_fixed() +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_tumour_branching.png")), height = 10, width = 13)
```

```{r fig_branching, fig.height=5, fig.width=13}
# can you show tumour and stroma network?
# limY <- quantile(branchingDT$`branch-distance`, probs = 0.98)[[1]]
# limY <- quantile(branchingDT$`euclidean-distance`, probs = 0.98)[[1]]

# ggplot(branchingDT, aes(centroid_x, centroid_y, color = as.factor(`branch-type`))) +
# ggplot(branchingDT, aes(centroid_x, centroid_y, color = `branch-distance`)) +
# ggplot(branchingDT, aes(centroid_x, centroid_y, color = `euclidean-distance`)) +
ggplot(datX, aes(stroma.centroid_x, stroma.centroid_y)) +
  theme_classic() +
  geom_point(size = 1, color = .flowColours(
    datX$stroma.centroid_x, datX$stroma.centroid_y)) +
  coord_fixed() +
  # scale_color_brewer(palette = "Set1") +
  # viridis::scale_colour_viridis(limits = c(0, limY)) +
  # viridis::scale_colour_viridis() +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

# ggsave(file.path(anaDir, 'clusters', 'aSf5Rr_branching_type.png'), height = 20, width = 30)
# ggsave(file.path(anaDir, 'clusters', 'aSf5Rr_branching_dist.png'), height = 20, width = 30)
# ggsave(file.path(anaDir, 'clusters', 'aSf5Rr_branching_density.png'), height = 20, width = 30)
```

```{r fig_branching_heat, fig.height=5, fig.width=13}
# show heatplots
branchingDT[, branch_pocket := 0]
branchingDT[`branch-type` > 0, branch_pocket := 1]

# for (i in unique(branchingDT$`branch-type`)) {
for (i in unique(branchingDT$branch_pocket)) {
  # xDT <- branchingDT[`branch-type` == i]
  xDT <- branchingDT[branch_pocket == i]

  p1 <- ggplot(xDT, aes(centroid_x, centroid_y)) +
    theme_classic() +
    geom_point(size = 0.5, color = .flowColours(xDT$centroid_x, xDT$centroid_y)) +
    coord_fixed() +
    viridis::scale_fill_viridis() +
    plotThemeDark(angle = 0) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      legend.position = "none"
    )
  
  print(p1)
  
  # ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_branching_", i, ".png")), height = 5, width = 8)
  ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_pocket_", i, ".png")), height = 5, width = 8)
}
```

```{r fig_region_stroma, fig.height=2, fig.width=3}
# now .. join spatial to distance of stroma in invasive region
stromaDT <- spatialDT %>%
  group_by(from) %>%
  summarise(neighbours = n()) %>%
  left_join(popStroma[, c("label", "stroma.dist", "stroma.contact", "pop", "centroid_x", "centroid_y")],
            by = c("from" = "label"))

stromaSummary <- stromaDT %>%
  group_by(neighbours, stroma.contact) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n) * 100) %>%
  dplyr::filter(stroma.contact == TRUE)

ggplot(stromaSummary, aes(neighbours, freq)) +
  theme_classic() +
  ylim(0, 100) +
  geom_col(fill = "black") +
  # geom_boxplot() +
  scale_fill_brewer(palette = "Set1") +
  theme(
    # axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    legend.title = element_blank(),
    legend.position = "bottom",
    legend.justification = "left"
  ) +
  xlab("Cell density (#)") + ylab("Stroma contact (%)") +
  ylim(0, 60)
  # coord_flip()

ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_branching_bars.pdf")),
       height = 2, width = 4)
```

```{r fig_branching, fig.height=8, fig.width=13}
ggplot(stromaDT, aes(centroid_x, centroid_y, color = neighbours)) +
  theme_classic() +
  geom_point(size = 0.5) +
  coord_fixed() +
  geom_point() +
  viridis::scale_colour_viridis(option = "inferno") +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

# ggsave(file.path(anaDir, 'clusters', 'aSf5Rr_neighbors.png'), height = 10, width = 15)
```

```{r fig_branching, fig.height=8, fig.width=13}
tumourClusters <- c("0", "9", "22", "23", "24")

limMax <- quantile(popDT[clusters %in% tumourClusters]$stroma.dist, probs = 0.999)[[1]]
limMin <- quantile(popDT[clusters %in% tumourClusters]$stroma.dist, probs = 0.001)[[1]]

x <- popDT[clusters %in% tumourClusters]
y <- popDT[!clusters %in% tumourClusters]
  
ggplot(popDT, aes(centroid_x, centroid_y)) +
  theme_classic() +
  geom_point(size = 0.5) +
  coord_fixed() +
  geom_point(data = y, size = 1, color = "#5B5B5B") +
  geom_point(data = x, size = 1, aes(color = stroma.dist)) +
  viridis::scale_colour_viridis(limits = c(limMin, limMax), option = "inferno") +
  plotThemeDark(angle = 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

# ggsave(file.path(anaDir, 'clusters', 'aSf5Rr_stroma_dist.png'), height = 10, width = 15)
```

```{r fig_stroma_ki67, fig.height=1, fig.width=1}
# can you show the distance of Ki67+ to stroma in contrast to other tumour?
xDT <- popDT[clusters %in% tumourClusters]
xDT[, is.prolif := FALSE]
xDT[clusters == "9", is.prolif := TRUE]

ggplot(xDT, aes(is.prolif, stroma.dist)) +
  theme_classic() +
  # geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  geom_jitter(width = 0.3, alpha = 1.0) +
  geom_boxplot(outlier.alpha = 0) 
```

```{r}
# can you cluster on numbers, freq and properties?
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "dpLvQE", versionID = versionID, initReactivity = FALSE # Set
)

# run task
funParams <- list(
  uIDs = c("aSf5Rr"),
  popType = c("branch"),
  pops = c("stroma.branch"),
  objectMeasures = c(
    # c("branch-distance", "euclidean-distance")
  ),
  includeCounts = FALSE,
  includeTotalCount = TRUE,
  colName = "default",
  valueName = "stroma.branch",
  excludeSelfConnections = FALSE,
  useClusters = FALSE,
  expandPops = TRUE,
  numClusters = 3
)

task <- cciaObj$runTask(
  funName = "clustRegions.kmeansClust",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# show regions of stroma
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE 
)

regionDT <- cciaObj$popDT(
  "region", includeFiltered = TRUE, completeDT = TRUE,
  completeValueNames = "stroma.branch", pops = c("root"))

# popDT <- cciaObj$popDT(
#   "clust", includeFiltered = TRUE, completeDT = TRUE,
#   popCols = c("pop", paste0("stroma.branch_type_", seq(0, 3))),
#   # pops = unlist(unname(cciaObj$popPaths("clust", includeFiltered = TRUE))),
#   pops = unlist(unname(cciaObj$popPaths("clust", includeFiltered = TRUE, includeRoot = TRUE))),
#   forceReload = TRUE)
```

```{r fig_branching_regions, fig.height=5, fig.width=8}
# plot out
ggplot(regionDT, aes(centroid_x, centroid_y, color = as.factor(regions))) +
  theme_classic() +
  plotThemeDark(angle = 0) +
  geom_point(size = 1, alpha = 0.2) +
  coord_fixed() +
  scale_color_brewer(palette = "Set1") +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    # legend.position = "none"
  )

# ggsave(file.path(anaDir, 'clusters', 'aSf5Rr_branching_regions.png'), height = 20, width = 20)
```

```{r fig_regions_heat, fig.height=5, fig.width=13}
# show heatplots
for (i in unique(regionDT$regions)) {
  xDT <- regionDT[regions == i]

  p1 <- ggplot(xDT, aes(centroid_x, centroid_y)) +
    theme_classic() +
    geom_point(size = 0.5, color = .flowColours(xDT$centroid_x, xDT$centroid_y)) +
    coord_fixed() +
    # viridis::scale_colour_viridis(limits = c(0, limY)) +
    plotThemeDark(angle = 0) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      legend.position = "none"
    )
  
  print(p1)
  
  ggsave(file.path(anaDir, "clusters", paste0("aSf5Rr_region_pockets_", i, ".png")), height = 5, width = 8)
}
```

```{r fig_regions_heat, fig.height=1.5, fig.width=2}
regionSummary <- regionDT %>% pivot_longer(
  cols = c(
    "stroma.branch/zero", "stroma.branch/three",
    "stroma.branch/one", "stroma.branch/two",
    # "sum", "branch-distance", "euclidean-distance"
    # "branch-distance", "euclidean-distance"
  ),
  names_to = "measure",
  values_to = "value"
) %>%
  group_by(measure, regions) %>%
  summarise(mean = mean(value, rm.na = TRUE)) %>%
  mutate(norm = (mean - min(mean))/(max(mean) - min(mean))) %>%
  replace_na(list(norm = 0))

ggplot(regionSummary, aes(regions, measure)) +
    theme_classic() +
    # geom_tile(aes(fill = mean), colour = "white", size = 0.5) +
    geom_tile(aes(fill = norm), colour = "white", size = 0.5) +
    viridis::scale_fill_viridis(
      breaks = c(0, 1),
      labels = c(0, 1)
    ) +
    theme(
      legend.position = "none",
      legend.title = element_blank(),
      legend.text = element_text(size = 20),
      legend.key.size = unit(10, "mm"),
      axis.text.y = element_text(size = 20),
      axis.text.x = element_text(size = 20),
      # axis.text.x = element_text(size = 20, angle = 45, hjust = 1, vjust = 1),
      strip.background = element_blank(),
      strip.text.x = element_blank()
      ) +
    xlab("") + ylab("")
```

```{r}
# find nearest neighbours
popNN <- dbscan::kNN(
  as.matrix(regionDT[, c('centroid_y', 'centroid_x')]),
  k = 1,
  query = as.matrix(popDT[, c('centroid_y', 'centroid_x')]))

# filter long distances
regionVals <- regionDT[popNN$id, ]$regions
# regionVals <- regionDT[popNN$id, ]$`branch-type`
regionVals[popNN$dist > 100 * cciaObj$omeXMLPixelRes()$x] <- -1

# assign regions to pops
popDT[, regionsNN := as.factor(regionVals)]
```

```{r fig_pop_branching, fig.height=3, fig.width=2.5}
summaryDT <- popDT %>%
  dplyr::filter(clusters != "2") %>%
  # drop_na() %>%
  # group_by(pop, regionsNN) %>%
  group_by(clusters, regionsNN) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n) * 100) %>%
  dplyr::filter(regionsNN != "-1")
  
# summaryDT$clusters <- recode(
#   summaryDT$clusters,
#   `0` = 'CD20+ B cell',
#   `1` = 'CD8+ T cell',
#   `2` = 'CD54+ 1',
#   `3` = 'Unspecified',
#   `4` = 'CD163+ Macro',
#   `5` = 'CD45+1',
#   `6` = 'CD4+ T cell',
#   `7` = 'CD54+ 2',
#   `8` = 'CD45+ 2',
#   `9` = 'CD54+ 3',
#   `10` = 'CD11c+ Macro',
#   `11` = 'CD15+ Macro',
#   `12` = 'CD54+ 4',
#   `13` = 'CD61+',
#   `14` = 'CD31+',
#   `15` = 'CD54+ 5',
#   `16` = 'Glyco.A+'
# )
# summaryDT$regionsNN <- recode(
#   summaryDT$regionsNN,
#   `1` = 'Loose',
#   `2` = 'Medium',
#   `3` = 'Dense'
# )

# ggplot(summaryDT, aes(pop, freq, fill = regionsNN)) +
# ggplot(summaryDT, aes(clusters, freq, fill = regionsNN)) +
ggplot(summaryDT, aes(reorder(clusters, freq), freq, fill = regionsNN)) +
  theme_classic() +
  # ylim(0, 100) +
  geom_col() +
  scale_fill_brewer(palette = "Set1") +
  theme(
    # axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    legend.title = element_blank(),
    legend.position = "bottom",
    legend.justification = "left"
  ) +
  xlab("") + ylab("Stroma region (%)") +
  coord_flip()
```

```{r}
# get populations and show maps
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "aSf5Rr", versionID = versionID, initReactivity = FALSE
)

# get label properties
labelDT <- as.data.table(cciaObj$labelProps("stroma")$as_df())
```

```{r}
# summaryDT <- labelDT %>% pivot_longer(
#   cols = c(
#     "eccentricity", "orientation", "extent", "solidity", "oblate",
#     "prolate", "aspect_ratio", "fill", "solidity"),
#   names_to = "measure",
#   values_to = "value"
# )
```

```{r fig_stroma, fig.height=5, fig.width=8}
# filter 
summaryDT <- labelDT[eccentricity > quantile(labelDT$eccentricity, probs = 0.05)[[1]]]

# plot shape of stroma
for (x in c("eccentricity", "orientation", "extent", "solidity", "oblate",
            "prolate", "aspect_ratio", "fill", "solidity", "aspect_ratio",
            "feret_diameter_max", "equivalent_diameter", "perimeter_to_area")) {
  limY <- quantile(summaryDT[[x]], probs = 0.98)[[1]]
  
  p1 <- ggplot(summaryDT, aes(centroid_x, centroid_y, color = get(x))) +
    theme_classic() +
    plotThemeDark(angle = 0) +
    geom_point(size = 0.5) +
    coord_fixed() +
    viridis::scale_colour_viridis(limits = c(0, limY)) +
    ggtitle(x) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      legend.position = "none"
    )
  
  print(p1)
}
```

```{r}
# show pops on image
Sys.setenv(KMP_DUPLICATE_LIB_OK = "TRUE")
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = TRUE, initJupyter = TRUE)
# cciaUse("~/cecelia/dev", initConda = FALSE, initJupyter = TRUE)

# start ipython kernel
viewer <- NapariUtils$new()

viewer$initNapari()
```

```{r}
generateScreenshots <- function(
    anaDir, cciaObj, uIDs, channelsToShow, popsToShow, fileAttrs,
    valueName = "default", matchChannels = FALSE, save = TRUE, pointsSize = NULL, ...) {
  
  # go through images and save movies
  for (x in cciaObj$cciaObjects(uIDs = uIDs)) {
    i <- x$getUID()
    viewer$setTaskDir(x$persistentObjectDirectory())
    
    # get channels
    imChannelNames <- x$imChannelNames()
    
    # match channels
    curChannelsToShow <- channelsToShow
    if (matchChannels == TRUE) {
      # TODO this is very crude    
      names(curChannelsToShow) <- sapply(names(channelsToShow), function(y) {
        imChannelNames[!is.na(stringr::str_extract(imChannelNames, y))][[1]]
      })
    }

    # get cmaps
    layersVisible <- imChannelNames %in% names(curChannelsToShow)
    channelColormaps <- rep("gray", length(layersVisible))
    
    for (j in names(curChannelsToShow))
      channelColormaps[[which(imChannelNames == j)]] <- curChannelsToShow[[j]]
    
    names(layersVisible) <- seq(length(layersVisible))
    
    # open image
    viewer$openImage(
      x$imFilepath(),
      imChannelNames = imChannelNames,
      show3D = FALSE,
      layersVisible = layersVisible,
      channelColormaps = channelColormaps
      # multiscales = as.integer(1)
    )
    
    # add populations
    popsAdded <- list()
    
    # show on image
    removePrevious <- TRUE
    
    if (is.null(pointsSize)) {
      pointsSize <- max(x$omeXMLPixels()$SizeX, x$omeXMLPixels()$SizeY) * 0.005
      # pointsSize <- max(x$omeXMLPixels()$SizeX, x$omeXMLPixels()$SizeY) * 0.003
    }
    
    # add populations to popMap
    for (popType in names(popsToShow)) {
      popMap <- x$imPopMap(popType, includeFiltered = TRUE)
      curPops <- popsToShow[[popType]]
    
      # get popIDs for paths
      popIDs <- lapply(names(curPops), function(y) x$popIDsByAttr(popType, "path", y, includeFiltered = TRUE))
      names(popIDs) <- names(curPops)
      
      for (pop in names(curPops)) {
        x$editPopColour(popType, popIDs[[pop]], curPops[[pop]], includeFiltered = TRUE)
      }
    
      # save to disk
      x$savePopMap(popType, includeFiltered = TRUE)
      x$savePops(popType, pops = names(popIDs),
                 purge = TRUE, includeFiltered = TRUE)
      
      for (j in names(curPops)) {
        viewer$showPopMapping(popType, valueName = popMap[[popIDs[[j]]]]$valueName,
                              pops = list(j), pointsSize = pointsSize,
                              execInteractive = FALSE, removePrevious = removePrevious)
        removePrevious <- FALSE
      }
    }
    
    # adjust channel intensities
    browser()
  
    # save screenshot
    if (save == TRUE)
      viewer$saveScreenshot(
        file.path(anaDir, paste0(
          paste(sapply(fileAttrs, function(i) x$getCciaAttr(i)), collapse = "_"), "_", i, ".png")),
        ...)
  }
}

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "dpLvQE", versionID = versionID, initReactivity = FALSE
)

uIDs <- c("aSf5Rr")

channelsToShow <- list(
  "CD4" = "yellow",
  "CD8A" = "cyan",
  "CD68" = "green",
  "ERBB2" = "red",
  "CEACAM6" = "bop orange",
  "AQP1" = "blue",
  "KRT14" = "gray"
  )
popsToShow <- list(
  region = list(
    "region.C" = "#ffd700",
    "region.E" = "#00fa9a",
    "region.G" = "#ff0000",
    "region.F" = "#e9967a",
    "region.A" = "#0000cd",
    "region.B" = "#f0e68c",
    "region.D" = "#ff1493"
  )
)
fileAttrs <- c()

# [1] "DCIS :  3"
# [1] "invasive :  0"
# [1] "others :  9, 10, 1, 2, 26, 19, 21, 20, 25, 12, 27, 16, 18, 17, 22, 11, 15, 23, 14, 13, 24"
# [1] "myoepithelium :  5"
# [1] "endothelial :  4"
# [1] "cd4 :  7"
# [1] "cd8 :  8"
# [1] "macs :  6"

generateScreenshots(
  file.path(anaDir, "images"), cciaObj, uIDs, channelsToShow,
  # file.path(anaDir, "pops"), cciaObj, uIDs, list(),
  # list(), fileAttrs, size = list(800, 800), save = TRUE)
  popsToShow, fileAttrs, size = NULL, save = TRUE, pointsSize = 40)
  # popsToShow, fileAttrs, size = list(1200, 1200), save = TRUE)
```