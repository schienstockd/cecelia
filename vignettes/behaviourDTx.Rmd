---
title: "Behaviour GCAMP"
output: html_document
date: '2022-08-15'
---

```{r setup, include=FALSE}
renv::load("~/R-workspace/cecelia/")
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
a <- readRDS("/Volumes/QUACK1/DOHERTY/CECELIA/projects/Lq0joh/ANALYSIS/11/IIIII0/ccid.rds")
```


## Show transition states of live cell imaging

```{r}
Sys.setenv(KMP_DUPLICATE_LIB_OK = "TRUE")
devtools::load_all("../")
cciaUse("~/cecelia/dev")

library(ggplot2)
library(tidyverse)
```

```{r}
# set test variables
pID <- "8BR53W"
versionID <- 1
projectsDir <- "/Volumes/Analysis_SSD/Dominik/cecelia/projects/"
hpcDir <- "/data/scratch/projects/punim1124/cecelia/USERS/schienstockd/"
```

```{r}
# HPC config
HPC_CONF <-  list(
  hpc = list(
    conf = list(
      email = "schienstockd@student.unimelb.edu.au",
      emailOnBegin = FALSE,
      emailOnEnd = FALSE,
      emailOnFail = TRUE,
      numNodes = 1,
      numTasks = 1,
      numCPUperTask = 1,
      numGPUperTask = 1,
      memory = 50,
      walltime = "00-06:00:00",
      projectPartitions = "physical",
      # projectPartitions = "gpu-a100",
      projectID = "punim1124",
      # projectID = "punim1031",
      useGPU = FALSE
      # useGPU = TRUE
    )
  ),
  utils = list(
    ssh = list(
      username = "schienstockd",
      address = "spartan.hpc.unimelb.edu.au",
      keyfile = "/Users/Dominik/.ssh/spartan_rsa"
    ),
    python = list(
      condaEnv = cciaConf()$python$conda$source$env
    )
  )
)
```

```{r}
anaDir <- "/Volumes/USER_data/Dominik/Experiments/JL-ANALYSIS/RESULTS/clusterTracks/movement"
```

```{r}
# rename
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  # pID = pID, uID = "ZXcUMO", versionID = versionID, initReactivity = FALSE # DTx
  pID = pID, uID = "wGqPEx", versionID = versionID, initReactivity = FALSE # DTx
)

# cciaObj$propagatePopMap("live", "iTfSUG")
# cciaObj$saveState()

cciaObj$popPaths("live", includeFiltered = TRUE)
```

```{r}
# rename
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "rXctjl", versionID = versionID, initReactivity = FALSE # DTx
)

for (x in cciaObj$cciaObjects()) {
  if (!file.exists(x$oriFilepath())) {
    print(x$getUID())
    print(x$oriFilepath())
    # x$setOriFilepath(str_replace(x$oriFilepath(), "\\.ims$", " drift_corrected.ims"))
    # x$saveState()
  }
  # str_replace(x$oriFilepath(), "\\.lsm$", ".ims"))
  # x$setCciaName(str_replace(x$getCciaName(), "\\.lsm$", ".ims"))
  # x$saveState()
}
```

```{r}
# segment images
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "ZXcUMO", versionID = versionID, initReactivity = FALSE # DTx
  # pID = pID, uID = "TWy8AS", versionID = versionID, initReactivity = FALSE # test
)

# get experimental info
exp.info <- as.data.table(cciaObj$summary(
  withSelf = FALSE, fields = c("Attr"),
  uIDs = uIDs
))

uIDs <- exp.info[Include == "Y"]$uID

# run task
funParams <- list(
  # valueName = "tcells.gBT",
  # valueName = "tcells.gDT",
  valueName = "dcs.TRITC",
  models = list(
    # "1" = list(
    #   "model" = "fluo",
    #   "matchAs" = "none",
    #   "cellDiameter" = 10,
    #   "cellChannels" = list("gBT"),
    #   "nucChannels" = list(),
    #   "normalise" = 99.9,
    #   "stitchThreshold" = 0.2,
    #   "mergeLabels" = FALSE,
    #   "threshold" = 0,
    #   "relTreshold" = 0,
    #   "gaussianFilter" = 0,
    #   "medianFilter" = 0
    # )
    # "1" = list(
    #   "model" = "fluo",
    #   "matchAs" = "none",
    #   "cellDiameter" = 10,
    #   "cellChannels" = list("gDT"),
    #   "nucChannels" = list(),
    #   "normalise" = 99.9,
    #   "stitchThreshold" = 0.2,
    #   "mergeLabels" = FALSE,
    #   "threshold" = 0,
    #   "relTreshold" = 0,
    #   "gaussianFilter" = 0,
    #   "medianFilter" = 0
    # )
    "1" = list(
      "model" = "fluo",
      "matchAs" = "none",
      "cellDiameter" = 10,
      "cellChannels" = list("TRITC"),
      "nucChannels" = list(),
      "normalise" = 99.9,
      "stitchThreshold" = 0.2,
      "mergeLabels" = FALSE,
      "threshold" = 0,
      "relTreshold" = 0,
      "gaussianFilter" = 0,
      "medianFilter" = 0
    )
  ),
  clearDepth = FALSE,
  clearTouchingBorder = FALSE,
  haloSize = 0,
  blockSize = -1,
  overlap = -1,
  blockSizeZ = -1,
  overlapZ = -1,
  context = 1,
  # segment = TRUE,
  segment = FALSE,
  measure = TRUE,
  updateMeasures = FALSE,
  extendedMeasures = TRUE,
  saveMeshes = TRUE,
  saveMeasures = TRUE,
  labelExpansion = 0,
  labelErosion = 0,
  minCellSize = 50,
  matchThreshold = 0.2,
  removeUnmatched = TRUE,
  labelOverlap = 0.2
)

# run task
task <- cciaObj$runTasks(
# task <- cciaObj$runTask(
  funName = "segment.cellpose",
  funParams = funParams,
  envVars = HPC_CONF,
  hpcDir = paste(hpcDir, pID, "ANALYSIS", sep = "/"),
  env = "hpc",
  runInplace = FALSE,
  taskID = 3,
  uIDs = uIDs
)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "xo3yvA", versionID = versionID, initReactivity = FALSE # DTx
)

cciaObj$imFilepath()
```


```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "ZXcUMO", versionID = versionID, initReactivity = FALSE # DTx
  # pID = pID, uID = "TWy8AS", versionID = versionID, initReactivity = FALSE # test
)

# get experimental info
exp.info <- as.data.table(cciaObj$summary(
  withSelf = FALSE, fields = c("Attr"),
  uIDs = uIDs
))

uIDs <- exp.info[Include == "Y"]$uID

funParams <- list(
  # valueNames = c("tcells.gBT", "tcells.gDT", "dcs.TRITC"),
  valueNames = c("tcells.gBT", "tcells.gDT"),
  retrieveMeshesOnly = FALSE
)

# run task
task <- cciaObj$runTasks(
  funName = "segment.retrieve",
  funParams = funParams,
  envVars = HPC_CONF,
  hpcDir = paste(hpcDir, pID, "ANALYSIS", sep = "/"),
  env = "local",
  runInplace = TRUE,
  taskID = 1,
  uIDs = uIDs,
  mc.cores = 3
)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "ZXcUMO", versionID = versionID, initReactivity = FALSE # DTx
)

# not useable
uIDs <- names(cciaObj$cciaObjects())
uIDs.exclude <- c(
  "5N8Iip", "OWJrYz", "PxwhNn",
  "CzR7ZQ", "zqrpfq",
  "NbaQvC", "ypUN8d", "oPmJg0",
  "o0auGO", "TxTL0a", "xyHt1U"
)
uIDs <- uIDs[!uIDs %in% uIDs.exclude]

attrVals.Y <- rep("Y", length(uIDs))
attrVals.N <- rep("N", length(uIDs.exclude))

names(attrVals.Y) <- uIDs
names(attrVals.N) <- uIDs.exclude

cciaObj$editAttrForCciaObjects(
  "Include", attrVals.Y, cciaObj$cciaObjects(uIDs = uIDs))
cciaObj$editAttrForCciaObjects(
  "Include", attrVals.N, cciaObj$cciaObjects(uIDs = uIDs.exclude))

cciaObj$saveState()
```

```{r}
# HMM
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "ZXcUMO", versionID = versionID, initReactivity = FALSE # DTx
  # pID = pID, uID = "TWy8AS", versionID = versionID, initReactivity = FALSE # test
)

# get experimental info
exp.info <- as.data.table(cciaObj$summary(
  withSelf = FALSE, fields = c("Attr")
))

uIDs <- exp.info[Include == "Y"]$uID

# run task
funParams <- list(
  popType = "live",
  pops = c("tcells.gBT/tracked", "tcells.gDT/tracked"),
  modelMeasurements = c("live.cell.speed", "live.cell.angle"),
  scaleMeasurements = c("live.cell.speed", "live.cell.angle"),
  # modelMeasurements = c(
  #   "surface_area", "volume", "extent", "solidity",
  #   "ellipticity_interm_oblate", "ellipticity_interm_prolate",
  #   "compactness", "sphericity"
  # ),
  colName = "movement",
  # colName = "shape",
  appendStates = list(live.cell.is.clust = TRUE),
  # appendStates = list(),
  skipTimesteps = 0,
  subtrackOverlap = TRUE,
  noiseFilterMeasurements = 5,
  postFiltering = 2,
  postIterations = 2,
  numStates = 3, # movement with injection
  # numStates = 3, # movement
  # numStates = 3, # shape,
  uIDs = uIDs
)

# run task
task <- cciaObj$runTask(
  funName = "behaviourAnalysis.hmmStates",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# get HMM transitions
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "ZXcUMO", versionID = versionID, initReactivity = FALSE # DTx
  # pID = pID, uID = "TWy8AS", versionID = versionID, initReactivity = FALSE # test
)

# get experimental info
exp.info <- as.data.table(cciaObj$summary(
  withSelf = FALSE, fields = c("Attr"),
  uIDs = uIDs
))

uIDs <- exp.info[Include == "Y"]$uID

# run task
funParams <- list(
  popType = "live",
  pops = c("tcells.gBT/tracked", "tcells.gDT/tracked"),
  colName = "movement",
  hmmStates = c("movement"),
  # colName = "shape",
  # hmmStates = c("shape"),
  includeStart = FALSE,
  includeSelfTransitions = TRUE,
  uIDs = uIDs
)

# run task
task <- cciaObj$runTask(
  funName = "behaviourAnalysis.hmmTransitions",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# cluster tracks based on transitions
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "ZXcUMO", versionID = versionID, initReactivity = FALSE # DTx
)

# get experimental info
exp.info <- as.data.table(cciaObj$summary(
  withSelf = FALSE, fields = c("Attr")
))

uIDs <- exp.info[Include == "Y"]$uID

# run task
funParams <- list(
  popType = "live",
  popsToCluster = c("tcells.gBT/tracked", "tcells.gDT/tracked"),
  # valueName = "tracks.clusters.tcells.movement",
  # clusterColName = "movement",
  # valueName = "tracks.clusters.tcells.hmm",
  # clusterColName = "hmm",
  # valueName = "tracks.clusters.tcells.hmm_movement",
  # clusterColName = "hmm_movement",
  valueName = "tracks.clusters.tcells.hmm_transitions_movement",
  clusterColName = "hmm_transitions_movement",
  # valueName = "tracks.clusters.tcells.hmm_movement",
  # clusterColName = "hmm_movement",
  # valueName = "tracks.clusters.tcells.hmm_transitions_movement_shape",
  # clusterColName = "hmm_transitions_movement_shape",
  resolution = 0.25,
  percentile = 99.5,
  trackMeasures = c(
    "speed",
    "duration",
    "trackLength",
    "meanTurningAngle",
    "displacement",
    "straightness",
    "displacementRatio",
    "outreachRatio",
    "asphericity",
    "overallAngle"
  ),
  objectMeasures = c(
    # "surface_area",
    # "volume",
    # "extent", 
    # "solidity",
    # "ellipticity_interm_oblate",
    # "ellipticity_interm_prolate",
    # "compactness",
    # "sphericity",
    # HMM states
    "live.cell.hmm.state.movement",
    "live.cell.hmm.transitions.movement"
    # "live.cell.hmm.state.shape",
    # "live.cell.hmm.transitions.shape"
    ),
  nMeasures = c(
    ),
  sumMeasures = c(
    ),
  calcMeasures = list(
  ),
  addPops = c(
    ),
  calcLabelProps = TRUE,
  # usePaga = FALSE,
  usePaga = TRUE,
  pagaThreshold = 0.1,
  minTracklength = 6,
  uIDs = uIDs
)

# run tasks for a range of parameters to compare cluster results
clustParams <- list(
  resolution = seq(0.20, 0.40, 0.05),
  percentile = seq(98.0, 99.5, 0.5)
)

# go through combos
paramCombs <- expand.grid(clustParams)

for (x in split(paramCombs, seq(nrow(paramCombs)))) {
  print(sprintf(">> Run task for %s", paste(x, collapse = " ")))
  
  # adjust parameters
  funParams$valueName = paste0(
    "tracks.clusters.tcells.hmm_transitions_movement_", paste(x, collapse = "_"))
  funParams$clusterColName = paste0(
    "hmm_transitions_movement_", paste(x, collapse = "_"))
  
  for (i in names(x)) {
    funParams[[i]] <- x[[i]]
  }
  
  # run task
  task <- cciaObj$runTask(
    funName = "behaviourAnalysis.clusterTracks",
    funParams = funParams,
    env = "local",
    runInplace = TRUE,
    taskID = 1
  )
}
```

```{r}
# create cluster trees
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "ZXcUMO", versionID = versionID, initReactivity = FALSE # DTx
)

# get experimental info
exp.info <- as.data.table(cciaObj$summary(
  withSelf = FALSE, fields = c("Attr")
))

uIDs <- exp.info[Include == "Y"]$uID

clustPrefix <- "tracks.clusters.tcells.hmm_transitions_movement_"
normPerc <- 99

clustFiles <- list.files(
  file.path(cciaObj$persistentObjectDirectory(), cciaConf()$dirs$tasks$labelProps),
  pattern = paste0(clustPrefix, sprintf(".*[0-9]+_%s.sc.h5ad", normPerc)))
clustFiles <- tools::file_path_sans_ext(basename(clustFiles))

# set names for files based on parameters
names(clustFiles) <- str_extract(clustFiles, sprintf("(?<=%s).*(?=\\_%s.sc)", clustPrefix, normPerc))

# how can you now combine clustering for to check which
# resolution is best for clustering?
tcells.sc <- lapply(clustFiles, function(x) {
  as.data.table(cciaEnv()$LabelPropsUtils(
    cciaObj$persistentObjectDirectory(),
    value_name = x)$label_props_view()$as_df())
})

# join tables together
for (i in names(tcells.sc)[2:length(tcells.sc)]) {
  clustName <- paste0("clusters_", i)
  
  tcells.sc[[1]][
    tcells.sc[[i]][, c("pop", "uID", "track_id", "clusters")],
    on = c("pop", "uID", "track_id"),
    (clustName) := i.clusters]
}

data.table::setnames(
  tcells.sc[[1]], "clusters", paste0("clusters_", names(tcells.sc)[[1]]))

tcells.sc <- tcells.sc[[1]]
```

```{r}
# # now follow the tutorial to plot
# # https://lazappi.github.io/clustree/articles/clustree.html
# library(clustree)
# 
# clustree(tcells.sc, prefix = "clusters_", node_colour = "sc3_stability")
```


```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "ZXcUMO", versionID = versionID, initReactivity = FALSE # DTx
)

# get experimental info
exp.info <- as.data.table(cciaObj$summary(
  withSelf = FALSE, fields = c("Attr", "oriFilepath")
))

data.table::fwrite(exp.info[Include == "Y"], file.path(anaDir, "exp_info.csv"))

uIDs <- exp.info[Include == "Y"]$uID

# get clustering
tcells.sc <- as.data.table(cciaEnv()$LabelPropsUtils(
  cciaObj$persistentObjectDirectory(),
  # value_name = "tracks.clusters.tcells.movement.sc")$label_props_view()$as_df())
  # value_name = "tracks.clusters.tcells.hmm.sc")$label_props_view()$as_df())
  # value_name = "tracks.clusters.tcells.hmm_movement.sc")$label_props_view()$as_df())
  value_name = "tracks.clusters.tcells.hmm_transitions_movement.sc")$label_props_view()$as_df())
  # value_name = "tracks.clusters.tcells.hmm_transitions_movement_shape.sc")$label_props_view()$as_df())

# get popDTs for set
popDTs <- cciaObj$popDT(
  popType = "live", pops = c(
    "tcells.gBT/tracked",
    "tcells.gDT/tracked",
    "dcs.TRITC/tracked"
    ),
  includeFiltered = TRUE,
  flushCache = TRUE,
  uIDs = uIDs)

# get neighbour information
# spatialDT <- cciaObj$spatialDT(valueName = "tcells.gBT", uIDs = uIDs)
# spatialDT.gDT <- cciaObj$spatialDT(valueName = "tcells.gDT", uIDs = uIDs)

# get track info
tracksMeasures <- cciaObj$tracksMeasures(pops = c("tcells.gBT/tracked"), uIDs = uIDs)
```

```{r}
clusterMapping <- list(
  Directed = c(0),
  Meandering = c(1,5),
  Scanning = c(2,4),
  Aggregating = c(3,6),
  NONE = c(7)
)

# map clusters
tcells.sc <- .mapClustNames(tcells.sc, clusterMapping)
```


```{r}
# join pops
spatialDT.sc <- copy(spatialDT[dist <= 30])
spatialDT.gDT.sc <- copy(spatialDT.gDT[dist <= 30])

spatialDT.sc[
  popDTs[pop == "tcells.gBT/tracked", c("uID", "label", "track_id")],
  on = c("uID", "to" = "label"),
  track_id.to := track_id]
spatialDT.sc[
  tcells.sc[pop == "tcells.gBT/tracked", c("uID", "track_id", "clusters")],
  on = c("uID", "track_id.to" = "track_id"),
  clusters.to := clusters]

spatialDT.gDT.sc[
  popDTs[pop == "tcells.gDT/tracked", c("uID", "label", "track_id")],
  on = c("uID", "to" = "label"),
  track_id.to := track_id]
spatialDT.gDT.sc[
  tcells.sc[pop == "tcells.gDT/tracked", c("uID", "track_id", "clusters")],
  on = c("uID", "track_id.to" = "track_id"),
  clusters.to := clusters]

# map clusters
spatialDT.sc <- .mapClustNames(spatialDT.sc, clusterMapping, clustCol = "clusters.to")
spatialDT.gDT.sc <- .mapClustNames(spatialDT.gDT.sc, clusterMapping, clustCol = "clusters.to")
```

```{r}
# get behaviour frequencies and then get kmeans
spatialDT.summary <- spatialDT.sc %>%
  group_by(uID, from, clusters.name) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n))

spatialDT.gDT.summary <- spatialDT.gDT.sc %>%
  group_by(uID, from, clusters.name) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n))
```

```{r fig_kmeans_clusters, fig.height=1.5, fig.width=2.5}
# use K-Means to get clusters of regions
normalit <- function(m) (m - min(m))/(max(m)-min(m))

spatialDT.summary.wider <- as.data.table(spatialDT.summary %>%
  # ungroup() %>%
  # mutate(norm = normalit(freq)) %>%
  pivot_wider(
    id_cols = c(uID, from),
    names_from = clusters.name,
    # names_from = clusters.from,
    # values_from = norm,
    values_from = freq,
    values_fill = 0
  ))

spatialDT.summary.mat <- as.matrix(spatialDT.summary.wider %>%
  ungroup() %>% 
  select(-c(uID, from)))
rownames(spatialDT.summary.mat) <- paste(spatialDT.summary.wider$uID, spatialDT.summary.wider$from)
```

```{r fig_kmeans_clusters, fig.height=1.5, fig.width=2.5}
# use K-Means to get clusters of regions
normalit <- function(m) (m - min(m))/(max(m)-min(m))

spatialDT.gDT.summary.wider <- as.data.table(spatialDT.gDT.summary %>%
  # ungroup() %>%
  # mutate(norm = normalit(freq)) %>%
  pivot_wider(
    id_cols = c(uID, from),
    names_from = clusters.name,
    # names_from = clusters.from,
    # values_from = norm,
    values_from = freq,
    values_fill = 0
  ))

spatialDT.gDT.summary.mat <- as.matrix(spatialDT.gDT.summary.wider %>%
  ungroup() %>% 
  select(-c(uID, from)))
rownames(spatialDT.gDT.summary.mat) <- paste(spatialDT.gDT.summary.wider$uID, spatialDT.gDT.summary.wider$from)
```

```{r fig_kmeans_clusters, fig.height=2, fig.width=4}
clustToFind <- 4

set.seed(55)

clusters <- kmeans(
  spatialDT.summary.wider %>%
    ungroup() %>%
    select(-c(uID, from)),
  clustToFind)
# mcl.model <- mclust::Mclust(freqRegionsMat)
# mcl.model <- mclust::Mclust(freqRegionsMat, clustToFind)

# Plot our results.
# plot(mcl.model, what = "classification", main = "Mclust Classification")

# push back clusters
spatialDT.summary.wider[, cluster := clusters$cluster]
# freqRegionsWider$cluster <- mcl.model$classification

popCols <- colnames(spatialDT.summary.wider)[!colnames(spatialDT.summary.wider) %in% c(
  "uID", "from", "to", "n", "cluster", "clusters.from", "clusters.to")]

spatialDT.summary.across <- spatialDT.summary.wider %>%
  group_by(cluster) %>%
  summarise(across(all_of(popCols), mean)) %>%
  pivot_longer(
    cols = popCols,
    names_to = "pop",
    values_to = "value"
    ) %>%
  mutate(norm = normalit(value))

ggplot(
  spatialDT.summary.across, aes(as.factor(cluster), pop)) +
  geom_tile(aes(fill = norm)) +
  viridis::scale_fill_viridis(discrete = FALSE, limits = c(0, 1)) +
  theme_classic() +
  theme(legend.title = element_blank()) +
  xlab("") + ylab("")

ggsave(file.path(anaDir, "heat_niches.png"), height = 2, width = 4)
```

```{r fig_kmeans_clusters, fig.height=2, fig.width=4}
clustToFind <- 2

set.seed(12)

clusters <- kmeans(
  spatialDT.gDT.summary.wider %>%
    ungroup() %>%
    select(-c(uID, from)),
  clustToFind)
# mcl.model <- mclust::Mclust(freqRegionsMat)
# mcl.model <- mclust::Mclust(freqRegionsMat, clustToFind)

# Plot our results.
# plot(mcl.model, what = "classification", main = "Mclust Classification")

# push back clusters
spatialDT.gDT.summary.wider[, cluster := clusters$cluster]

popCols <- colnames(spatialDT.gDT.summary.wider)[!colnames(spatialDT.gDT.summary.wider) %in% c(
  "uID", "from", "to", "n", "cluster", "clusters.from", "clusters.to")]

spatialDT.gDT.summary.across <- spatialDT.gDT.summary.wider %>%
  group_by(cluster) %>%
  summarise(across(all_of(popCols), mean)) %>%
  pivot_longer(
    cols = popCols,
    names_to = "pop",
    values_to = "value"
    ) %>%
  mutate(norm = normalit(value))

ggplot(
  spatialDT.gDT.summary.across, aes(as.factor(cluster), pop)) +
  geom_tile(aes(fill = norm)) +
  viridis::scale_fill_viridis(discrete = FALSE, limits = c(0, 1)) +
  theme_classic() +
  theme(legend.title = element_blank()) +
  xlab("") + ylab("")

ggsave(file.path(anaDir, "heat_niches_gDT.png"), height = 2, width = 4)
```

```{r fig_region_freq, fig.height=3, fig.width=6}
# show frequency of populations for treatments
spatialDT.summary.exp <- copy(spatialDT.summary.wider) %>%
  group_by(uID, cluster) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n) * 100) %>%
  ungroup() %>%
  complete(uID, cluster, fill = list(freq = 0)) %>%
  left_join(exp.info)

# plot
ggplot(spatialDT.summary.exp,
       aes(as.factor(cluster), freq, color = interaction(Treatment, DTx))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(
    position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
    # width = 0.3, alpha = 0.6) +
  # stat_summary(fun=mean, geom="point", size=3, shape=18, color="Magenta") +
  ylab("Population (%)") + xlab("") +
  # ylim(0, 1) +
  scale_color_brewer(name = NULL, palette = "Set1")

ggsave(file.path(anaDir, "freq_niches.png"), height = 2, width = 6)

# summaryDF$Treatment <- 0
# summaryDF[summaryDF$Cohort == "ICI" & summaryDF$Response == "Yes",]$Treatment <- 1

# save as csv for plotting in Prism
# data.table::fwrite(summaryDF, file.path(anaDir, "cluster_regions.csv"))
```

```{r fig_region_freq, fig.height=3, fig.width=6}
# show frequency of populations for treatments
spatialDT.gDT.summary.exp <- copy(spatialDT.gDT.summary.wider) %>%
  group_by(uID, cluster) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n) * 100) %>%
  ungroup() %>%
  complete(uID, cluster, fill = list(freq = 0)) %>%
  left_join(exp.info)

# plot
ggplot(spatialDT.gDT.summary.exp,
       aes(as.factor(cluster), freq, color = interaction(Treatment, DTx))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(
    position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
    # width = 0.3, alpha = 0.6) +
  # stat_summary(fun=mean, geom="point", size=3, shape=18, color="Magenta") +
  ylab("Population (%)") + xlab("") +
  # ylim(0, 1) +
  scale_color_brewer(name = NULL, palette = "Set1")

ggsave(file.path(anaDir, "freq_niches_gDT.png"), height = 2, width = 6)

# summaryDF$Treatment <- 0
# summaryDF[summaryDF$Cohort == "ICI" & summaryDF$Response == "Yes",]$Treatment <- 1

# save as csv for plotting in Prism
# data.table::fwrite(summaryDF, file.path(anaDir, "cluster_regions.csv"))
```

```{r}
popDTs.niches.gDT <- copy(popDTs[value_name == "tcells.gDT"])
popDTs.niches.gBT <- copy(popDTs[value_name == "tcells.gBT"])

# popDTs.niches.gDT[
#   spatialDT.summary.wider[, c("uID", "from", "cluster")],
#   on = c("uID", "live.cell.contact_id#live.tcells.gBT__tracked" = "from"),
#   niche.cluster := cluster]
# 
# popDTs.niches.gDT <- .mapClustNames(
#   popDTs.niches.gDT, clusterMapping, "live.cell.track.clusters.hmm_transitions_movement",
#   nameCol = "self.clusters.name", idCol = "self.contact.clusters.id")

popDTs.niches.gDT[
  spatialDT.gDT.summary.wider[, c("uID", "from", "cluster")],
  on = c("uID", "label" = "from"),
  niche.cluster := cluster]

popDTs.niches.gDT <- .mapClustNames(
  popDTs.niches.gDT, clusterMapping, "live.cell.track.clusters.hmm_transitions_movement",
  nameCol = "clusters.name")

popDTs.niches.gBT[
  spatialDT.summary.wider[, c("uID", "from", "cluster")],
  on = c("uID", "label" = "from"),
  niche.cluster := cluster]

popDTs.niches.gBT <- .mapClustNames(
  popDTs.niches.gBT, clusterMapping, "live.cell.track.clusters.hmm_transitions_movement",
  nameCol = "clusters.name")
```

```{r fig_region_freq, fig.height=20, fig.width=40}
# show regions
p1s <- list()

colPal <- list(
  "1" = "#ebd441",
  "2" = "#4682b4",
  "3" = "#AA1F5E",
  "4" = "#B3BCC2"
)

for (i in uIDs) {
  local_i <- local(i)
  
  x <- exp.info[uID == i]
  
  p1 <- ggplot(popDTs.niches.gBT[uID == i] %>% drop_na(niche.cluster) %>% left_join(exp.info),
               aes(centroid_x, -centroid_y, color = as.factor(niche.cluster))) +
    # geom_point(data = popDTs.niches.gDT[niche.cluster != 1] %>% left_join(exp.info), size = 0.8, color = "black", fill = "darkgrey", shape = 21) +
    # geom_point(data = popDTs[pop == "dcs.TRITC/tracked"] %>% left_join(exp.info), size = 0.8, color = "black", fill = "yellow", shape = 21) +
    # geom_point(size = 0.8) +
    # geom_point(data = popDTs.niches.gDT[niche.cluster == 1] %>% left_join(exp.info), size = 0.8, color = "black", fill = "white", shape = 21) +
    geom_density2d(data = popDTs[uID == i & pop == "dcs.TRITC/tracked"], size = 0.4, color = "dimgray") +
    geom_point(data = popDTs.niches.gDT[uID == i & niche.cluster != 1], size = 0.4, color = "darkslategray") +
    geom_point(size = 0.4) +
    geom_point(data = popDTs.niches.gDT[uID == i & niche.cluster == 1], size = 0.4, color = "white") +
    theme_classic() +
    coord_fixed() +
    # scale_color_brewer(name = NULL, palette = "Set1") +
    scale_color_manual(values = colPal) +
    plotThemeDark() +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      # legend.position = "none"
    ) +
    # facet_wrap(.~interaction(Treatment, DTx)+uID, ncol = 10) +
    guides(colour = guide_legend(override.aes = list(size = 3)))
  
  # ggsave(file.path(anaDir, "niches.png"), height = 10, width = 20, plot = p1)
  ggsave(file.path(anaDir, "niches", paste0("niches_", x$Treatment, "_", x$DTx, "_", i, ".png")), height = 5, width = 5, plot = p1)
}
```

```{r fig_dens_behaviour, fig.height=6, fig.width=6}
popDTs.niches.gBT[, in_contour := 0]
popDTs.niches.gDT[, in_contour := 0]

# set params
n = 25
contourLevels = seq(1, 0, -0.1)
extendLimits = 0.5

# get location of behaviour classes according to TRITC density
for (i in uIDs) {
  local_i <- local(i)
  
  print(paste(">>", local_i))
  
  x.gBT <- popDTs.niches.gBT[uID == local_i]
  x.gDT <- popDTs.niches.gDT[uID == local_i]
  x.TRITC <- popDTs[uID == local_i & pop == "dcs.TRITC/tracked"]
  
  dens <- MASS::kde2d(
    # x.TRITC$centroid_x, x.TRITC$centroid_y, n = n,
    # lims = c(
    #   range(x.TRITC$centroid_x) * c(1 - extendLimits, 1 + extendLimits),
    #   range(x.TRITC$centroid_y) * c(1 - extendLimits, 1 + extendLimits)
    #   ))
    x.gBT$centroid_x, x.gBT$centroid_y, n = n,
    lims = c(
      range(x.gBT$centroid_x) * c(1 - extendLimits, 1 + extendLimits),
      range(x.gBT$centroid_y) * c(1 - extendLimits, 1 + extendLimits)
      ))
  
  # get z range
  zRange <- range(dens$z)
    
  # normalise z
  dens$z <- (dens$z - zRange[[1]]) / (zRange[[2]] - zRange[[1]])
  
  # create contour levels
  confidenceLines <- contourLines(dens, levels = contourLevels)
  
  # create dataframe for lines
  confidenceDT <- data.table::rbindlist(
    mapply(function(x, i) {
      as.data.table(
        list(
          level = x$level,
          seq = i,
          x = x$x,
          y = x$y
        ))
    }, confidenceLines, seq(length(confidenceLines)),
    SIMPLIFY = FALSE)
  )
  
  # determine points in contour
  # get larges contour
  # x.gBT[, in_contour := 0]
  x.gDT[, in_contour := 0]
  
  # go through contours
  for (i in seq(length(confidenceLines))) {
    x <- confidenceDT[seq == i,]
    y <- as.numeric(x$level[[1]])
    
    # x.gBT[
    x.gDT[
      in_contour == 0,
      in_contour := as.numeric(sp::point.in.polygon(
        # x.gBT[in_contour == 0, centroid_x],
        # x.gBT[in_contour == 0, centroid_y],
        x.gDT[in_contour == 0, centroid_x],
        x.gDT[in_contour == 0, centroid_y],
        x$x, x$y
       )) * y]
  }
  
  # push back
  # popDTs.niches.gBT[uID == local_i, in_contour := x.gBT$in_contour]
  popDTs.niches.gDT[uID == local_i, in_contour := x.gDT$in_contour]
}
```

```{r fig_dens_behaviour, fig.height=6, fig.width=6}
# ggplot(x.gBT, aes(centroid_x, -centroid_y, color = in_contour)) +
ggplot(x.gDT, aes(centroid_x, -centroid_y, color = in_contour)) +
  geom_polygon(
    data = confidenceDT,
    aes(x = x, y = -y, group = as.factor(-seq)),
    size = 0.2, color = "black", fill = "white") +
  geom_point(size = 0.5) +
  theme_classic() +
  coord_fixed() +
  viridis::scale_color_viridis() +
  # scale_color_brewer(name = NULL, palette = "Set1") +
  # plotThemeDark() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    # legend.position = "none"
  )
```


```{r fig_dens_behaviour, fig.height=4, fig.width=12}
# can you plot out the behaviour sections according to TRITC density?
# datToPlot <- popDTs.niches.gBT %>%
datToPlot <- popDTs.niches.gDT %>%
  group_by(uID, in_contour, clusters.name) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  ungroup() %>%
  complete(uID, in_contour, clusters.name, fill = list(freq = 0)) %>%
  left_join(exp.info)

# ggplot(datToPlot, aes(as.factor(in_contour), freq, color = clusters.name)) +
ggplot(datToPlot, aes(in_contour, freq, color = clusters.name, fill = clusters.name)) +
  theme_classic() +
  # geom_violin(scale = "width") +
  # geom_boxplot(outlier.alpha = 0) +
  # geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  geom_smooth() +
  # ylab("Behaviour (%)") + xlab("HMM") +
  # ylab("Behaviour (%)") + xlab("Niche") +
  scale_color_brewer(name = NULL, palette = "Set1") +
  scale_fill_brewer(name = NULL, palette = "Set1") +
  facet_grid(.~interaction(Treatment, DTx))

# ggsave(file.path(anaDir, "behaviour_TRITC_dens.png"), height = 2, width = 8)
# ggsave(file.path(anaDir, "behaviour_gBT_dens.png"), height = 2, width = 8)
ggsave(file.path(anaDir, "behaviour_gDT_to_gBT_dens.png"), height = 2, width = 8)
```
```{r fig_dens_behaviour, fig.height=4, fig.width=12}
# can you plot out the behaviour sections according to TRITC density?
# datToPlot <- popDTs.niches.gBT %>%
datToPlot <- popDTs.niches.gDT %>%
  group_by(uID, in_contour, clusters.name) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  ungroup() %>%
  complete(uID, in_contour, clusters.name, fill = list(freq = 0)) %>%
  left_join(exp.info)

# ggplot(datToPlot, aes(as.factor(in_contour), freq, color = clusters.name)) +
p1 <- ggplot(datToPlot, aes(in_contour, freq, color = clusters.name, fill = clusters.name)) +
  theme_classic() +
  # geom_violin(scale = "width") +
  # geom_boxplot(outlier.alpha = 0) +
  # geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  geom_smooth() +
  # ylab("Behaviour (%)") + xlab("HMM") +
  # ylab("Behaviour (%)") + xlab("Niche") +
  scale_color_brewer(name = NULL, palette = "Set1") +
  scale_fill_brewer(name = NULL, palette = "Set1") +
  facet_wrap(.~interaction(Treatment, DTx)+uID, ncol = 10)

# ggsave(file.path(anaDir, "behaviour_TRITC_dens_indv.png"), height = 8, width = 20, plot = p1)
# ggsave(file.path(anaDir, "behaviour_gBT_dens_indv.png"), height = 8, width = 20, plot = p1)
ggsave(file.path(anaDir, "behaviour_gDT_to_gBT_dens_indv.png"), height = 8, width = 20, plot = p1)
```

```{r fig_dens_behaviour, fig.height=4, fig.width=12}
# can you plot out the behaviour sections according to TRITC density?
datToPlot <- popDTs.niches.gBT %>%
  group_by(uID, in_contour, clusters.name) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  ungroup() %>%
  complete(uID, in_contour, clusters.name, fill = list(freq = 0)) %>%
  left_join(exp.info)

# ggplot(datToPlot, aes(as.factor(in_contour), freq, color = clusters.name)) +
ggplot(datToPlot, aes(in_contour, freq, color = clusters.name, fill = clusters.name)) +
  theme_classic() +
  # geom_violin(scale = "width") +
  # geom_boxplot(outlier.alpha = 0) +
  # geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  geom_smooth() +
  # ylab("Behaviour (%)") + xlab("HMM") +
  # ylab("Behaviour (%)") + xlab("Niche") +
  scale_color_brewer(name = NULL, palette = "Set1") +
  scale_fill_brewer(name = NULL, palette = "Set1") +
  facet_grid(.~interaction(Treatment, DTx))
```

```{r fig_region_freq, fig.height=5, fig.width=5}
# show regions
p1 <- ggplot(popDTs.niches.gDT %>% left_join(exp.info), aes(centroid_x, centroid_y, color = as.factor(niche.cluster))) +
  geom_point(size = 0.5) +
  theme_classic() +
  coord_fixed() +
  scale_color_brewer(name = NULL, palette = "Set1") +
  # plotThemeDark() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    # legend.position = "none"
  ) +
  facet_wrap(.~interaction(Treatment, DTx)+uID, ncol = 10)

ggsave(file.path(anaDir, "niches_gDT.png"), height = 10, width = 20, plot = p1)
```

```{r fig_region_freq, fig.height=3, fig.width=8}
niche.aggregating <- 2

# can you just plot out the behaviour of cells in and outside of a niche
popDTs.niches.gBT[, in.niche.cluster := niche.cluster == niche.aggregating]

# summaryToPlot <- popDTs.niches.gBT[live.cell.hmm.state.movement != 4,] %>%
summaryToPlot <- popDTs.niches.gBT %>%
  drop_na(in.niche.cluster, live.cell.hmm.state.movement) %>%
  group_by(uID, in.niche.cluster, live.cell.hmm.state.movement) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  ungroup() %>%
  complete(uID, in.niche.cluster, live.cell.hmm.state.movement, fill = list(freq = 0)) %>%
  left_join(exp.info)

ggplot(summaryToPlot, 
       aes(as.factor(live.cell.hmm.state.movement), freq, color = in.niche.cluster)) +
       # aes(as.factor(niche.cluster), freq, color = interaction(Treatment, DTx))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  ylab("Behaviour (%)") + xlab("HMM") +
  # ylab("Behaviour (%)") + xlab("Niche") +
  scale_color_brewer(name = NULL, palette = "Set1") +
  facet_grid(.~interaction(Treatment, DTx))

ggsave(file.path(anaDir, "behaviour_in_niche.png"), height = 2, width = 8)
# ggsave(file.path(anaDir, "behaviour_in_niche_wo.png"), height = 2, width = 8)
```

```{r}
# filter on aggregating niches
spatialDT.niche <- copy(spatialDT.summary.wider[
  cluster == niche.aggregating, c("uID", "from")])

spatialDT.niche.dist <- spatialDT[
  spatialDT.niche, on = c("uID", "to" = "from"), nomatch = NULL]

# then add behaviour cluster
spatialDT.niche.dist[
  popDTs.niches.gBT, on = c("uID", "from" = "label"),
  `:=` (from.track_id = track_id, from.niche.cluster = niche.cluster)]

# drop na, spatial is on complete segmentation
# spatialDT.niche.dist <- spatialDT.niche.dist[!is.na(spatialDT.niche.dist$from.track_id),]

# then plot out

# summarise per track
spatialDT.niche.dist.summary <- spatialDT.niche.dist %>%
  group_by(uID, from.track_id) %>%
  summarise(median.dist = median(dist, na.rm = TRUE)) %>%
  rename(track_id = from.track_id) %>%
  left_join(
    (spatialDT.niche.dist %>%
      drop_na(from.niche.cluster) %>%
      group_by(uID, from.track_id, from.niche.cluster) %>%
      summarise(n = n()) %>%
      mutate(freq = n/sum(n)) %>%
      pivot_wider(names_from = from.niche.cluster, values_from = freq, values_fill = 0, id_cols = c("uID", "from.track_id")) %>%
      rename(track_id = from.track_id)), by = c("uID", "track_id")
  )

rm(spatialDT.niche)
rm(spatialDT.niche.dist)
```

```{r fig_speed_to_niche, fig.height=10, fig.width=20}
# can you show the speed of gBT in relation to aggregating gBT?
# and/or show behaviour in relation to aggregates
p1 <- ggplot(spatialDT.niche.dist.summary %>%
         left_join(tracksMeasures) %>%
         left_join(exp.info), aes(median.dist, speed)) +
  theme_classic() +
  geom_smooth() +
  facet_wrap(.~interaction(Treatment, DTx)+uID, ncol = 10)

ggsave(file.path(anaDir, "niches_dist_speed_indv.png"), height = 10, width = 20, plot = p1)
```

```{r fig_speed_to_niche, fig.height=4, fig.width=10}
# can you show the speed of gBT in relation to aggregating gBT?
# and/or show behaviour in relation to aggregates
p1 <- ggplot(spatialDT.niche.dist.summary %>%
         left_join(tracksMeasures) %>%
         left_join(exp.info), aes(median.dist, speed)) +
  theme_classic() +
  geom_smooth() +
  facet_grid(.~interaction(Treatment, DTx))

ggsave(file.path(anaDir, "niches_dist_speed.png"), height = 3, width = 8, plot = p1)
```

```{r fig_time_in_niche, fig.height=2, fig.width=14}
# can you show the time spent of every behaviour in each cluster
summaryToPlot <- popDTs.niches.gBT %>%
  drop_na(clusters.name, niche.cluster) %>%
  group_by(uID, clusters.name, niche.cluster) %>%
  summarise(n = n()) %>%
  # mutate(freq = n/sum(n)) %>%
  left_join(spatialDT.summary.exp %>% group_by(uID, cluster) %>% summarise(m = sum(n)) %>% rename(niche.cluster = cluster)) %>%
  mutate(freq = n / m) %>%
  ungroup() %>%
  complete(uID, clusters.name, niche.cluster, fill = list(freq = 0)) %>%
  left_join(exp.info)

# ggplot(summaryToPlot, aes(clusters.name, freq, color = as.factor(niche.cluster))) +
ggplot(summaryToPlot, aes(clusters.name, freq, color = interaction(Treatment, DTx))) +
  theme_classic() +
  # geom_violin(scale = "width") +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  # ylab("Behaviour (%)") + xlab("HMM") +
  # ylab("Behaviour (%)") + xlab("Niche") +
  scale_color_brewer(name = NULL, palette = "Set1") +
  # facet_wrap(.~interaction(Treatment, DTx), ncol = 10)
  facet_wrap(.~niche.cluster, ncol = 10)

# ggsave(file.path(anaDir, "behaviour_time_spent_niches.png"), height = 2, width = 12)
# ggsave(file.path(anaDir, "behaviour_time_spent_niches_alt.png"), height = 2, width = 14)
ggsave(file.path(anaDir, "behaviour_time_spent_niches_alt2.png"), height = 2, width = 14)
```

```{r fig_time_in_niche, fig.height=2, fig.width=14}
# niche size
summaryToPlot <- popDTs.niches.gBT %>%
  drop_na(clusters.name, niche.cluster) %>%
  group_by(uID, clusters.name, niche.cluster) %>%
  summarise(n = n()) %>%
  group_by(uID, niche.cluster) %>%
  summarise(m = n()) %>%
  mutate(freq = n/m) %>%
  ungroup() %>%
  complete(uID, clusters.name, niche.cluster, fill = list(freq = 0)) %>%
  left_join(exp.info)

# ggplot(summaryToPlot, aes(clusters.name, freq, color = as.factor(niche.cluster))) +
ggplot(summaryToPlot, aes(clusters.name, freq, color = interaction(Treatment, DTx))) +
  theme_classic() +
  # geom_violin(scale = "width") +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  # ylab("Behaviour (%)") + xlab("HMM") +
  # ylab("Behaviour (%)") + xlab("Niche") +
  scale_color_brewer(name = NULL, palette = "Set1") +
  # facet_wrap(.~interaction(Treatment, DTx), ncol = 10)
  facet_wrap(.~niche.cluster, ncol = 10)

# ggsave(file.path(anaDir, "behaviour_time_spent_niches.png"), height = 2, width = 12)
ggsave(file.path(anaDir, "behaviour_time_spent_niches_alt.png"), height = 2, width = 14)
```


```{r fig_speed_to_niche, fig.height=4, fig.width=10}
# can you show the speed of gBT in relation to aggregating gBT?
# and/or show behaviour in relation to aggregates
summaryToPlot <- spatialDT.niche.dist.summary %>%
  left_join(tcells.sc) %>%
  mutate(
    dist.bin = cut(median.dist, breaks = seq(0, 100, 10), labels = seq(0, 90, 10)),
    dist.bin = as.numeric(as.character(dist.bin))
    ) %>%
  drop_na(clusters.name) %>%
  group_by(uID, dist.bin, clusters.name) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  left_join(exp.info)

p1 <- ggplot(summaryToPlot, aes(dist.bin, freq, color = clusters.name, fill = clusters.name)) +
  theme_classic() +
  geom_line(size = 1.5) +
  scale_color_brewer(name = NULL, palette = "Set1") +
  facet_wrap(.~interaction(Treatment, DTx)+uID, ncol = 10)

ggsave(file.path(anaDir, "niches_dist_behaviour_indv.png"), height = 10, width = 20, plot = p1)
```

```{r fig_speed_to_niche, fig.height=4, fig.width=10}
# can you show the speed of gBT in relation to aggregating gBT?
# and/or show behaviour in relation to aggregates
summaryToPlot <- spatialDT.niche.dist.summary %>%
  left_join(tcells.sc) %>%
  mutate(
    dist.bin = cut(median.dist, breaks = seq(0, 100, 10), labels = seq(0, 90, 10)),
    dist.bin = as.numeric(as.character(dist.bin))
    ) %>%
  drop_na(clusters.name) %>%
  group_by(uID, dist.bin, clusters.name) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  left_join(exp.info)

p1 <- ggplot(summaryToPlot, aes(dist.bin, freq, color = clusters.name, fill = clusters.name)) +
  theme_classic() +
  # geom_line(size = 1.5) +
  geom_smooth() +
  scale_color_brewer(name = NULL, palette = "Set1") +
  scale_fill_brewer(name = NULL, palette = "Set1") +
  facet_grid(.~interaction(Treatment, DTx))

ggsave(file.path(anaDir, "niches_dist_behaviour.png"), height = 3, width = 8, plot = p1)
```

```{r fig_region_freq, fig.height=5, fig.width=5}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# get you get individual niches/clusters and then take the distances
# of the cells to the border of those niches
i <- "4ZrNE2"

xdata <- popDTs.niches.gBT[uID == i & niche.cluster == niche.aggregating]
xpoints <- xdata[, c("centroid_x", "centroid_y")]

# get individual niches
clusters <- dbscan::dbscan(xpoints, eps = 20, minPts = 10, borderPoints = TRUE)
xdata[, dbscan := clusters$cluster]

xchull <- chull(as.matrix(xpoints))

# polyCoords <- xpoints[chull(as.matrix(xpoints)),] %>%
#   arrange(desc(row_number()))
# W <- spatstat.geom::owin(poly = list(x = polyCoords$centroid_x, y = polyCoords$centroid_y))

ggplot(xdata[xchull,], aes(centroid_x, centroid_y, color = as.factor(dbscan))) +
  geom_point(size = 0.5) +
  theme_classic() +
  coord_fixed() +
  scale_color_brewer(name = NULL, palette = "Set1") +
  # plotThemeDark() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    # legend.position = "none"
  )
```

```{r fig_niches_gDT_HMM, fig.height=3, fig.width=14}
niches.summary <- popDTs.niches.gDT %>%
  drop_na(live.cell.hmm.state.movement, niche.cluster) %>%
  group_by(uID, niche.cluster, live.cell.hmm.state.movement) %>%
  # group_by(uID, self.clusters.name, niche.cluster) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  ungroup() %>%
  complete(uID, niche.cluster, live.cell.hmm.state.movement, fill = list(freq = 0)) %>%
  # complete(uID, self.clusters.name, niche.cluster, fill = list(freq = 0)) %>%
  left_join(exp.info)

# can you now map the gDT HMM behaviour to these regions?
ggplot(niches.summary, 
       aes(as.factor(live.cell.hmm.state.movement), freq, color = interaction(Treatment, DTx))) +
       # aes(as.factor(niche.cluster), freq, color = interaction(Treatment, DTx))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  ylab("Behaviour (%)") + xlab("HMM") +
  # ylab("Behaviour (%)") + xlab("Niche") +
  scale_color_brewer(name = NULL, palette = "Set1") +
  facet_grid(.~niche.cluster)
  # facet_grid(.~self.clusters.name)
```

```{r fig_niches_gDT_behaviour, fig.height=3, fig.width=14}
niches.summary <- popDTs.niches %>%
  drop_na(self.clusters.name, niche.cluster) %>%
  group_by(uID, niche.cluster, self.clusters.name) %>%
  # group_by(uID, self.clusters.name, niche.cluster) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  ungroup() %>%
  complete(uID, niche.cluster, self.clusters.name, fill = list(freq = 0)) %>%
  # complete(uID, self.clusters.name, niche.cluster, fill = list(freq = 0)) %>%
  left_join(exp.info)

# can you now map the gDT HMM behaviour to these regions?
ggplot(niches.summary, 
       aes(as.factor(self.clusters.name), freq, color = interaction(Treatment, DTx))) +
       # aes(as.factor(niche.cluster), freq, color = interaction(Treatment, DTx))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  ylab("Behaviour (%)") + xlab("") +
  # ylab("Behaviour (%)") + xlab("Niche") +
  scale_color_brewer(name = NULL, palette = "Set1") +
  facet_grid(.~niche.cluster)
  # facet_grid(.~self.clusters.name)
```

```{r fig_region_freq, fig.height=3, fig.width=14}
niches.summary <- popDTs.niches %>%
  drop_na(self.clusters.name, niche.cluster) %>%
  # group_by(uID, niche.cluster, self.clusters.name) %>%
  group_by(uID, self.clusters.name, niche.cluster) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  ungroup() %>%
  # complete(uID, niche.cluster, self.clusters.name, fill = list(freq = 0)) %>%
  complete(uID, self.clusters.name, niche.cluster, fill = list(freq = 0)) %>%
  left_join(exp.info)

# can you now map the gDT HMM behaviour to these regions?
ggplot(niches.summary, 
       # aes(as.factor(self.clusters.name), freq, color = interaction(Treatment, DTx))) +
       aes(as.factor(interaction(Treatment, DTx)), freq, color = as.factor(niche.cluster))) +
       # aes(as.factor(niche.cluster), freq, color = interaction(Treatment, DTx))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  ylab("Behaviour (%)") + xlab("") +
  # ylab("Behaviour (%)") + xlab("Niche") +
  scale_color_brewer(name = NULL, palette = "Set1") +
  # facet_grid(.~niche.cluster)
  facet_grid(.~self.clusters.name)
  # facet_grid(.~self.clusters.name)

ggsave(file.path(anaDir, "freq_clusters_niches.png"), height = 2, width = 14)
```

```{r fig_region_freq, fig.height=3, fig.width=5}
niches.summary <- popDTs.niches[self.clusters.name == "Scanning"] %>%
  drop_na(self.clusters.name, niche.cluster) %>%
  # group_by(uID, niche.cluster, self.clusters.name) %>%
  group_by(uID, niche.cluster) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  ungroup() %>%
  # complete(uID, niche.cluster, self.clusters.name, fill = list(freq = 0)) %>%
  complete(uID, niche.cluster, fill = list(freq = 0)) %>%
  left_join(exp.info)

# can you now map the gDT HMM behaviour to these regions?
ggplot(niches.summary, 
       # aes(as.factor(self.clusters.name), freq, color = interaction(Treatment, DTx))) +
       aes(niche.cluster, freq, group = uID)) +
       # aes(as.factor(niche.cluster), freq, color = interaction(Treatment, DTx))) +
  theme_classic() +
  # geom_boxplot(outlier.alpha = 0) +
  # geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  geom_point() +
  ylab("Behaviour (%)") + xlab("") +
  # ylab("Behaviour (%)") + xlab("Niche") +
  scale_color_brewer(name = NULL, palette = "Set1") +
  facet_grid(.~interaction(Treatment, DTx)) +
  geom_line(alpha = 0.4)

# ggsave(file.path(anaDir, "freq_clusters_niches.png"), height = 2, width = 14)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# can you show the speed of gDT close and far away from gBT clusters
popDT.gDT <- copy(popDTs[pop == "tcells.gDT/tracked"])
tcells.sc.gDT <- copy(tcells.sc[pop == "tcells.gDT/tracked"])

# get own behaviour
popDT.gDT <- .mapClustNames(
  popDT.gDT, clusterMapping, "live.cell.track.clusters.hmm_transitions_movement",
  nameCol = "self.clusters.name", idCol = "self.contact.clusters.id")
```

```{r fig_gDT_behaviour, fig.height=3, fig.width=12}
# now plot out median distance of behaviour to aggregating cells
datToPlot <- popDT.gDT %>%
  group_by(uID, self.clusters.name, track_id) %>%
  summarise(
    median.dist = median(`live.cell.min_distance#live.tcells.gBT__tracked__clustered`, na.rm = TRUE),
    mean.dist = mean(`live.cell.min_distance#live.tcells.gBT__tracked__clustered`, na.rm = TRUE),
    mean.speed = mean(live.cell.speed, na.rm = TRUE)
    ) %>%
  mutate(niche.contact = median.dist < 20) %>%
  left_join(exp.info) %>%
  drop_na(niche.contact)

ggplot(datToPlot, 
       # aes(as.factor(self.clusters.name), median.dist, color = interaction(Treatment, DTx))) +
       aes(interaction(Treatment, DTx), median.dist, color = as.factor(self.clusters.name))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  scale_color_brewer(name = NULL, palette = "Set1") 

ggsave(file.path(anaDir, "gDT_behaviour_distance_gBT_cluster.png"), height = 2, width = 8)

ggplot(datToPlot, 
       aes(interaction(Treatment, DTx), mean.speed, color = as.factor(niche.contact))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  scale_color_brewer(name = NULL, palette = "Set1") 

ggsave(file.path(anaDir, "gDT_speed_niche_gBT_cluster.png"), height = 2, width = 8)

datToPlot <- datToPlot %>%
  group_by(uID, niche.contact, self.clusters.name) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  left_join(exp.info) %>%
  drop_na(niche.contact)

ggplot(datToPlot,
       aes(niche.contact, freq, color = as.factor(self.clusters.name))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  scale_color_brewer(name = NULL, palette = "Set1") +
  facet_grid(.~interaction(Treatment, DTx))

ggsave(file.path(anaDir, "gDT_behaviour_niche_gBT_cluster.png"), height = 2, width = 8)
```

```{r fig_gDT_behaviour, fig.height=3, fig.width=12}
datToPlot <- popDT.gDT %>%
  mutate(niche.contact = `live.cell.min_distance#live.tcells.gBT__tracked__clustered` < 20) %>%
  left_join(exp.info)

# can you plot speed for close and away cells? ie/ not tracks but individual cells
ggplot(datToPlot, 
       # aes(as.factor(self.clusters.name), median.dist, color = interaction(Treatment, DTx))) +
       aes(interaction(Treatment, DTx), `live.cell.min_distance#live.tcells.gBT__tracked__clustered`,
           color = as.factor(live.cell.hmm.state.movement))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  scale_color_brewer(name = NULL, palette = "Set1") 

ggsave(file.path(anaDir, "gDT_HMM_behaviour_distance_gBT_cluster.png"), height = 2, width = 8)

ggplot(datToPlot, 
       aes(interaction(Treatment, DTx), live.cell.speed, color = as.factor(niche.contact))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  scale_color_brewer(name = NULL, palette = "Set1") 

ggsave(file.path(anaDir, "gDT_HMM_speed_niche_gBT_cluster.png"), height = 2, width = 8)

datToPlot <- datToPlot %>%
  group_by(uID, niche.contact, live.cell.hmm.state.movement) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  left_join(exp.info) %>%
  drop_na(niche.contact)

ggplot(datToPlot,
       aes(niche.contact, freq, color = as.factor(live.cell.hmm.state.movement))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  scale_color_brewer(name = NULL, palette = "Set1") +
  facet_grid(.~interaction(Treatment, DTx))

ggsave(file.path(anaDir, "gDT_HMM_behaviour_niche_gBT_cluster.png"), height = 2, width = 8)
```



```{r}
# how many movies and mice per treatment?
exp.info %>% group_by(Treatment, DTx, Date) %>%
# exp.info %>% group_by(Treatment, DTx) %>%
  summarise(movies = n()) %>%
  group_by(interaction(Treatment, DTx)) %>%
  summarise(
    mice = n(),
    sum_movies = sum(movies)
    ) %>%
  mutate(movies_per_mouse = sum_movies/mice)
```


```{r fig_TRITC_contact, fig.height=5, fig.width=8}
# plot out TRTIC contact
datToPlot <- popDTs %>%
  dplyr::filter(value_name == "tcells.gBT") %>%
  group_by(uID, live.cell.is.clust, `live.cell.contact#live.dcs.TRITC/tracked`) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n) * 100) %>%
  # drop_na() %>%
  ungroup() %>%
  complete(uID, live.cell.is.clust,
           `live.cell.contact#live.dcs.TRITC/tracked`, fill = list(freq = 0)) %>%
  left_join(exp.info) %>%
  dplyr::filter(
    Treatment != "Uninfected",
    `live.cell.contact#live.dcs.TRITC/tracked` == TRUE
    ) 

ggplot(datToPlot, aes(live.cell.is.clust, freq,
                      color = interaction(Treatment, DTx))) +
    theme_classic() +
    geom_boxplot(outlier.alpha = 0) +
    geom_jitter(
      position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
    scale_color_brewer(name = "Treatment", palette = "Set1")

datToPlot$Treatment.ID <- 0
datToPlot[datToPlot$DTx == "DTx",]$Treatment.ID <- 1

datToPlot$pop.ID <- 0
datToPlot[datToPlot$live.cell.is.clust == TRUE,]$pop.ID <- 1

# data.table::fwrite(datToPlot, file.path(anaDir, "TRITC_contact.csv"))
```


```{r fig_hmm_props, fig.height=3, fig.width=3}
# show measurements of clusters to compare
colsToPlot <- rev(c(
  "angle",
  "speed",
  "compactness",
  "extent",
  "oblate",
  "prolate",
  "solidity",
  "sphericity",
  "surface_area",
  "volume"
))

# convert angle to degrees
popDTs[, live.cell.angle_deg := pracma::rad2deg(live.cell.angle)]

propsToPlot <- popDTs[exp.info, on = "uID"] %>%
  dplyr::rename(
    "speed" = "live.cell.speed",
    "angle" = "live.cell.angle_deg",
    "oblate" = "ellipticity_interm_oblate",
    "prolate" = "ellipticity_interm_prolate"
  ) %>%
  # drop_na(live.cell.hmm.state.hybrid_pop) %>%
  pivot_longer(
    cols = colsToPlot, names_to = "prop", values_to = "value"
    ) %>%
  pivot_longer(
    cols = c(
      "live.cell.hmm.state.movement"
      # "live.cell.hmm.state.shape"
    ), names_to = "hmm_type", values_to = "hmm_value"
    )

propsToPlot$prop <- factor(propsToPlot$prop, levels = colsToPlot)

# show heatmap for HMM
propsSummary <- propsToPlot %>%
  dplyr::filter(!is.na(hmm_value)) %>%
  group_by(hmm_type, hmm_value, prop) %>%
  replace_na(list(value = 0)) %>%
  summarise(mean = mean(value)) %>%
  group_by(hmm_type, prop) %>%
  mutate(freq = (mean - min(mean)) / (max(mean) - min(mean))) %>%
  arrange(-prop)

ggplot(propsSummary %>% dplyr::filter(hmm_value != "Clustering"), aes(as.factor(hmm_value), prop)) +
  theme_classic() +
  geom_tile(aes(fill = freq), colour = "white", size = 0.5) +
  viridis::scale_fill_viridis(
    breaks = c(0, 1),
    labels = c(0, 1)
  ) +
  theme(
    legend.position = "none",
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12),
    strip.background = element_blank(),
    strip.text.x = element_blank(),
    # axis.text.x = element_text(size = 12, angle = 45, hjust = 1, vjust = 1)
    ) +
  xlab("") + ylab("") +
  facet_grid(.~hmm_type)

ggsave(file.path(anaDir, "HMM_heat.pdf"), width = 2.3, height = 3)
```

```{r fig_umap, fig.height=8, fig.width=8}
dfToPlot <- copy(tcells.sc) %>% drop_na(clusters) %>% left_join(exp.info)

dfToPlot <- .mapClustNames(dfToPlot, clusterMapping, "clusters")

# get mean positions of clusters
meanClusterPos <- dfToPlot %>%
  group_by(clusters) %>%
  # group_by(clusters.name) %>%
  summarise(
    UMAP_1 = mean(UMAP_1),
    UMAP_2 = mean(UMAP_2)
  )
dfToPlot$clusters <- factor(dfToPlot$clusters)

colPal <- randomcoloR::distinctColorPalette(length(unique(dfToPlot$clusters)))

# plot UMAP
ggplot(
  dfToPlot,
  aes(UMAP_1, UMAP_2)
  ) +
  geom_point(aes(color = clusters)) +
  # geom_point(aes(color = clusters.name)) +
  theme_classic() +
  scale_color_brewer(name = NULL, palette = "Set1") +
  # scale_color_manual(values = colPal) +
  theme(
    axis.text = element_text(size = 15),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.justification = "right",
    # legend.position = "bottom"
    legend.position = "none",
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
    ) +
  geom_label(
    data = meanClusterPos,
    aes(label = clusters),
    # aes(label = clusters.name),
    label.size = 0.25,
    color = "black"
    )

ggsave(file.path(anaDir, "umap.tiff"), width = 2, height = 2)
# ggsave(file.path(anaDir, "umap_wo_labels.tiff"), width = 2, height = 2)
# ggsave(file.path(anaDir, "umap_hmm.tiff"), width = 2, height = 2)
# ggsave(file.path(anaDir, "umap_movement_wo_labels.tiff"), width = 2, height = 2)
# ggsave(file.path(anaDir, "umap_hmm_movement_wo_labels.tiff"), width = 2, height = 2)
# ggsave(file.path(anaDir, "umap_hmm_movement_shape_wo_labels.tiff"), width = 2, height = 2)
```

```{r fig_umap_props, fig.height=4, fig.width=4}
datToPlot <- copy(tcells.sc) %>%
  drop_na(clusters) %>%
  left_join(exp.info) 

# plot UMAP
ggplot(datToPlot, aes(UMAP_1, UMAP_2)) +
  theme_classic() +
  geom_point(aes(color = speed), size = 1, alpha = 1) +
  # geom_point(aes(color = meanTurningAngle), size = 1, alpha = 1) +
  viridis::scale_color_viridis() +
  theme(
    axis.text = element_text(size = 15),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.justification = "right",
    # legend.position = "bottom"
    legend.position = "none",
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
    )

ggsave(file.path(anaDir, paste0("umap_Velocity.tiff")), width = 2, height = 2)
# ggsave(file.path(anaDir, paste0("umap_Angle.tiff")), width = 2, height = 2)
```

```{r fig_umap, fig.height=4, fig.width=4}
plot.p1 <- function(df.all, df.subset) {
  plot.colours <- .flowColours(df.subset$UMAP_1, df.subset$UMAP_2, colramp = viridisLite::inferno)
  
  ggplot(df.all, aes(UMAP_1, UMAP_2)) +
    theme_classic() +
    geom_point(color = "black", size = 1) +
    geom_point(data = df.subset, color = plot.colours, size = 1, alpha = 1) +
    theme(
      axis.text = element_text(size = 15),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      legend.justification = "right",
      # legend.position = "bottom"
      legend.position = "none",
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank()
      )
}

datToPlot <- copy(tcells.sc) %>%
  drop_na(clusters) %>%
  left_join(exp.info)

datToPlot <- .mapClustNames(datToPlot, clusterMapping, "clusters")

# # get equal number of points
# numPoints <- min(table(datToPlot[, c("uID", "pop")]))
# datToPlot <- datToPlot %>% group_by(stain) %>% slice_sample(n = numPoints)

# plot UMAP
plot.p1(datToPlot, datToPlot %>% dplyr::filter(Treatment != "HSV"))
ggsave(file.path(anaDir, paste0("umap_Uninf.tiff")), width = 2, height = 2)

plot.p1(datToPlot, datToPlot %>% dplyr::filter(Treatment == "HSV" & DTx == "PBS"))
ggsave(file.path(anaDir, paste0("umap_HSV_PBS.tiff")), width = 2, height = 2)

plot.p1(datToPlot, datToPlot %>% dplyr::filter(Treatment == "HSV" & DTx != "PBS"))
ggsave(file.path(anaDir, paste0("umap_HSV_DTx.tiff")), width = 2, height = 2)

for (i in unique(datToPlot$pop)) {
  x <- stringr::str_replace_all(i, "\\/", "_")
  
  plot.p1(datToPlot, datToPlot %>% dplyr::filter(pop == i, Treatment != "HSV"))
  ggsave(file.path(anaDir, paste0("umap_Uninf_", x, ".tiff")), width = 2, height = 2)
  
  plot.p1(datToPlot, datToPlot %>% dplyr::filter(pop == i, Treatment == "HSV" & DTx == "PBS"))
  ggsave(file.path(anaDir, paste0("umap_HSV_PBS_", x, ".tiff")), width = 2, height = 2)
  
  plot.p1(datToPlot, datToPlot %>% dplyr::filter(pop == i, Treatment == "HSV" & DTx != "PBS"))
  ggsave(file.path(anaDir, paste0("umap_HSV_DTx_", x, ".tiff")), width = 2, height = 2)
}
```


```{r fig_umap, fig.height=4, fig.width=4}
# can you plot treatments together?
plot.p1 <- function(df.all, df.subset) {
  ggplot(df.all, aes(UMAP_1, UMAP_2, fill = pop)) +
    theme_classic() +
    geom_point(color = "black", size = 1) +
    geom_point(data = df.subset, size = 1.5, alpha = 1, pch = 21, color = "black", stroke = 0.4) +
    theme(
      axis.text = element_text(size = 15),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      legend.justification = "right",
      # legend.position = "bottom",
      legend.position = "none",
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank()
      ) +
    # scale_fill_brewer(name = "Treatment", palette = "Accent")
    scale_fill_manual(values = c("white", "#00c5ff"))
}

datToPlot <- copy(tcells.sc) %>%
  drop_na(clusters) %>%
  left_join(exp.info)

datToPlot <- .mapClustNames(datToPlot, clusterMapping, "clusters")

plot.p1(datToPlot, datToPlot %>% dplyr::filter(Treatment != "HSV"))
ggsave(file.path(anaDir, paste0("umap_Uninf.tiff")), width = 2, height = 2)

plot.p1(datToPlot, datToPlot %>% dplyr::filter(Treatment == "HSV" & DTx == "PBS"))
ggsave(file.path(anaDir, paste0("umap_HSV_PBS.tiff")), width = 2, height = 2)

plot.p1(datToPlot, datToPlot %>% dplyr::filter(Treatment == "HSV" & DTx != "PBS"))
ggsave(file.path(anaDir, paste0("umap_HSV_DTx.tiff")), width = 2, height = 2)
```

```{r fig_umap, fig.height=4, fig.width=4}
# can you show the progression of behaviour clusters from infected to uninfected?
clusterOrder <- c(1,3,6,0,7,2,5,4)
clusterColours <- c("grey", viridisLite::viridis(length(clusterOrder) - 1))

dfToPlot <- as.data.table(copy(tcells.sc) %>% drop_na(clusters) %>% left_join(exp.info))
dfToPlot <- dfToPlot[clusters %in% clusterOrder]
dfToPlot[, clusters := factor(clusters, levels = clusterOrder)]

# show progression on UMAP
ggplot(
  dfToPlot,
  aes(UMAP_1, UMAP_2)
  ) +
  geom_point(aes(color = clusters)) +
  theme_classic() +
  scale_color_manual(values = clusterColours) +
  theme(
    axis.text = element_text(size = 15),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.justification = "right",
    # legend.position = "bottom"
    legend.position = "none",
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
    )

ggsave(file.path(anaDir, paste0("umap_Progression.tiff")), width = 2, height = 2)
```

```{r}
# show measurements of clusters to compare
propsToPlot <- copy(tcells.sc)

propsToPlot <- .mapClustNames(propsToPlot, clusterMapping, "clusters")

# propsToPlot <- propsToPlot %>%
#   dplyr::rename(
#     "Movement HMM 1" = "live.cell.hmm.state.movement.1",
#     "Movement HMM 2" = "live.cell.hmm.state.movement.2",
#     "Movement HMM 3" = "live.cell.hmm.state.movement.3",
#     "Movement HMM 4" = "live.cell.hmm.state.movement.4",
#   )

colsToPlot <- colnames(propsToPlot)[!colnames(propsToPlot) %in% c(
  "pop", "uID", "track_id", "clusters", "clusters.id", "clusters.name", "UMAP_1", "UMAP_2"
  )]

propsToPlot <- propsToPlot %>%
  pivot_longer(
    cols = colsToPlot, names_to = "prop", values_to = "value"
    )

propsToPlot$prop <- factor(propsToPlot$prop, levels = sort(colsToPlot, decreasing = TRUE))

# propsList <- c(
#   'Movement HMM 1',
#   'Movement HMM 2',
#   'Movement HMM 3',
#   'Movement HMM 4',
#   'asphericity',
#   'displacement',
#   'displacementRatio',
#   'duration',
#   'meanTurningAngle',
#   'outreachRatio',
#   'overallAngle',
#   'speed',
#   'straightness',
#   'trackLength'
# )

# show heatmap for clusters
propsSummary <- propsToPlot %>%
  dplyr::filter(
    # clusters.name != "NONE",
    # prop %in% propsList
    ) %>%
  # group_by(clusters, prop) %>%
  group_by(clusters.name, prop) %>%
  summarise(mean = mean(value, rm.na = TRUE)) %>%
  group_by(prop) %>%
  mutate(freq = (mean - min(mean)) / (max(mean) - min(mean))) %>%
  arrange(-prop)
```


```{r fig_clusters_heat, fig.height=8, fig.width=6}
# propsSummary$prop <- factor(
#   propsSummary$prop, levels = rev(propsList))
# propsSummary$clusters.name <- factor(
#   propsSummary$clusters.name, levels = c(
#     "Directed", "Meandering", "Scanning", "Clustering"
#   ))

# # sort states
# propsSummary[!propsSummary$clusters %in% clusterOrder[clusterOrder != 1],]$clusters <- NA
# # propsSummary$clusters <- factor(propsSummary$clusters, levels = clusterOrder)
# propsSummary$clusters <- case_match(
#   as.character(propsSummary$clusters),
#   c("3") ~ "1",
#   c("6") ~ "2",
#   c("0") ~ "3",
#   c("7") ~ "4",
#   c("2") ~ "5",
#   c("5") ~ "6",
#   c("4") ~ "7",
# )

# ggplot(propsSummary, aes(as.factor(clusters.name), prop)) +
# ggplot(propsSummary, aes(as.factor(clusters), prop)) +
ggplot(propsSummary %>%
         dplyr::filter(!str_detect(prop, "live.cell")) %>%
         # dplyr::filter(!clusters %in% c(7)) %>%
         # drop_na(clusters), aes(clusters, prop)) +
         drop_na(clusters.name), aes(clusters.name, prop)) +
  theme_classic() +
  geom_tile(aes(fill = freq), colour = "white", size = 0.5) +
  viridis::scale_fill_viridis(
    breaks = c(0, 1),
    labels = c(0, 1)
  ) +
  theme(
    legend.position = "none",
    legend.key.size = unit(8, "mm"),
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    # axis.text.x = element_text(size = 12),
    axis.text.x = element_text(size = 12, angle = 45, hjust = 1, vjust = 1),
    strip.background = element_blank(),
    strip.text.x = element_blank()
    ) +
  xlab("") + ylab("")

ggsave(file.path(anaDir, "clusters_heat.pdf"), width = 2.8, height = 3)
# ggsave(file.path(anaDir, "clusters_heat_crop.pdf"), width = 3.2, height = 2.5)
# ggsave(file.path(anaDir, "clusters_heat.pdf"), width = 5, height = 14)
```

```{r fig_clusters_heat, fig.height=2, fig.width=6}
# get frequencies of HMM for each cluster
# and plot as bar graphs
datToPlot <- copy(popDTs)

datToPlot <- .mapClustNames(datToPlot, clusterMapping, "live.cell.track.clusters.hmm_transitions_movement") %>%
  mutate(live.cell.track.clusters.hmm_transitions_movement = as.numeric(as.character(
    live.cell.track.clusters.hmm_transitions_movement))) %>%
  drop_na(live.cell.track.clusters.hmm_transitions_movement) %>%
  drop_na(live.cell.hmm.state.movement) %>%
  group_by(live.cell.track.clusters.hmm_transitions_movement, live.cell.hmm.state.movement) %>%
  # group_by(clusters.name, live.cell.hmm.state.movement) %>%
  summarise(n = n()) %>%
  mutate(freq = n / sum(n) * 1) %>%
  ungroup() %>%
  complete(live.cell.track.clusters.hmm_transitions_movement, live.cell.hmm.state.movement, fill = list(freq = 0))
  # complete(clusters.name, live.cell.hmm.state.movement, fill = list(freq = 0))

data.table::fwrite(datToPlot, file = file.path(anaDir, "freq_hmm.csv"))

ggplot(datToPlot, aes(as.factor(live.cell.track.clusters.hmm_transitions_movement), freq,
# ggplot(datToPlot, aes(clusters.name, freq,
                      fill = as.factor(live.cell.hmm.state.movement))) +
  theme_classic() +
  # scale_fill_brewer(palette = "Accent") +
  scale_fill_manual(values = wesanderson::wes_palette(name = "Darjeeling2")) +
  theme_classic() +
  geom_bar(stat = "identity", width = 1, color = "black", size = 0.4) +
  theme(
    # legend.position = "none",
    legend.position = "right",
    legend.key.size = unit(6, "mm"),
    legend.title = element_blank(),
    legend.text = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    axis.title.x = element_text(size = 16),
    axis.text.y = element_text(size = 16),
    axis.text.x = element_text(size = 16),
    # axis.text.x = element_text(size = 12, angle = 45, hjust = 1, vjust = 1),
    strip.background = element_blank(),
    # strip.text.x = element_blank()
    strip.text.x = element_text(size = 16)
    ) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  # scale_fill_discrete(name = "HMM State") +
  # xlab("Clusters") + ylab("HMM proportion") +
  xlab("") + ylab("HMM proportion") +
  coord_flip()

# ggsave(file.path(anaDir, "clusters_hmm_heat.pdf"), width = 4, height = 2)
```

```{r fig_clusters_heat, fig.height=3, fig.width=8}
# get frequencies of HMM for each cluster
# and plot as bar graphs
datToPlot <- popDTs %>%
  mutate(
    live.cell.track.clusters.hmm_transitions_movement = as.numeric(as.character(
      live.cell.track.clusters.hmm_transitions_movement)),
    live.cell.hmm.transitions.movement = as.character(
      live.cell.hmm.transitions.movement)
    ) %>%
  drop_na(live.cell.track.clusters.hmm_transitions_movement) %>%
  dplyr::filter(live.cell.hmm.transitions.movement != "NA") %>%
  # group_by(live.cell.track.clusters.hmm_transitions_movement, from, to) %>%
  # dplyr::filter(!live.cell.hmm.transitions.movement %in% paste0(seq(4), "_", seq(4))) %>%
  group_by(live.cell.track.clusters.hmm_transitions_movement, live.cell.hmm.transitions.movement) %>%
  summarise(n = n()) %>%
  mutate(freq = n / sum(n) * 1) %>%
  separate_wider_delim(
    live.cell.hmm.transitions.movement, delim = "_", names = c("from", "to"))
  # ungroup() %>%
  # complete(live.cell.track.clusters.hmm_transitions_movement, from, to, fill = list(freq = 0))

ggplot(datToPlot, aes(as.factor(from), as.factor(to), size = freq * 2, fill = freq)) +
  theme_classic() +
  # scale_fill_brewer(palette = "Accent") +
  # scale_y_continuous(breaks = c(0, 0.5, 1)) +
  geom_vline(xintercept = as.factor(1:4), color = "#d3d3d3") +
  geom_hline(yintercept = as.factor(1:4), color = "#d3d3d3") +
  geom_point(pch = 21, color = "black") +
  # viridis::scale_fill_viridis() +
  scale_fill_gradient2(
    midpoint = 0.5, low="blue", mid="white", high="red", space ="Lab") +
  theme(
    legend.position = "none",
    # legend.position = "right",
    legend.key.size = unit(6, "mm"),
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12),
    # axis.text.x = element_text(size = 12, angle = 45, hjust = 1, vjust = 1),
    strip.background = element_blank(),
    # strip.text.x = element_blank()
    strip.text.x = element_text(size = 12)
    ) +
  # scale_fill_discrete(name = "HMM State") +
  xlab("From state") + ylab("To state") +
  facet_wrap(.~live.cell.track.clusters.hmm_transitions_movement, nrow = 2)

ggsave(file.path(anaDir, "clusters_transitions_heat.pdf"), width = 4, height = 3)
```

```{r fig_total_transitions, fig.height=1, fig.width=5}
library(ggplot2)
library(ggraph)

freqThr <- 0.00

pList <- list()

stateOrder <- list(
  "D" = "1",
  "M" = "3",
  "S" = "2",
  "C" = "4"
)

summaryDF <- popDTs %>%
  left_join(exp.info)

summaryDF$cell_type <- str_extract(summaryDF$pop, "(?<=\\.)[:alnum:]+(?=/)")
summaryDF$stain <- str_extract(
  summaryDF$staining, sprintf("%s-[:alnum:]+", summaryDF$cell_type)
  )
summaryDF$stain[is.na(summaryDF$stain)] <- "gBT-CTV"

summaryDF$clusters.name <- "NONE"


# for (x in unique(summaryDF$live.cell.track.clusters.hmm_movement)) {
for (x in unique(summaryDF$live.cell.track.clusters.hmm_transitions_movement)) {
# for (x in unique(summaryDF$live.cell.track.clusters.hmm_transitions_movement_shape)) {
# for (x in unique(summaryDF$clusters.name)) {
  # plot heatmap of transitions
  DF <- summaryDF %>%
    # dplyr::filter(live.cell.track.clusters.hmm_movement == x) %>%
    dplyr::filter(live.cell.track.clusters.hmm_transitions_movement == x) %>%
    # dplyr::filter(live.cell.track.clusters.hmm_transitions_movement_shape == x) %>%
    # dplyr::filter(clusters.name == x) %>%
    group_by(live.cell.hmm.transitions.movement) %>%
    summarise(n = n()) %>%
    separate(live.cell.hmm.transitions.movement,
             into = c("from", "to"),
             sep = "_", convert = TRUE) %>%
    mutate(across(c(from, to), as.character)) %>%
    replace_na(list(from = "0"))
  
  # edges for non-self transitions
  edges <- DF %>%
    dplyr::filter(from != to) %>%
    mutate(freq = n/sum(n)) %>%
    ungroup() %>%
    complete(from, to, fill = list(freq = 0)) %>%
    # drop_na() %>%
    # dplyr::filter(freq > freqThr) %>%
    mutate(non.self = (freq - min(freq)) / (max(freq) - min(freq))) %>%
    arrange(freq)
  
  # get number of self transitions
  nodes <- DF %>%
    dplyr::filter(from == to) %>%
    mutate(freq = n/sum(n)) %>%
    complete(from = unlist(stateOrder), fill = list(freq = 0)) %>%
    replace_na(list(to = "0")) %>%
    select(from, freq) %>%
    dplyr::rename(node = from) %>%
    add_row(node = "0", freq = 0) %>%
    mutate(nodeName = node) %>%
    dplyr::filter(node %in% unique(c(edges$from, edges$to))) %>%
    mutate(self = (freq - min(freq)) / (max(freq) - min(freq)))
  
  # add names for nodes
  for (i in names(stateOrder)) {
    nodes[nodes$nodeName == stateOrder[[i]], ]$nodeName <- i
  }
  
  # add state order
  counter <- 0
  nodes$order <- 0
  for (y in stateOrder) {
    nodes[nodes$node == y,]$order <- counter

    counter <- counter + 1
  }
  
  # https://www.hydrogenwaterusa.com/visualizing-large-directed-networks-with-ggraph-in-r/
  g <- igraph::graph_from_data_frame(d = edges,
                                     vertices = nodes %>% arrange(order),
                                     directed = TRUE)
  
  # pList[[x]] <- ggraph(g, layout = "auto") +
  # pList[[x]] <- ggraph(g, layout = "igraph", algorithm = "circle") +
  # pList[[x]] <- ggraph(g, layout = "linear") +
  ggraph(g, layout = "igraph", algorithm = "grid") +
  # ggraph(g, layout = "matrix") +
  # ggraph(g, layout = "auto") +
  # ggraph(g, layout = "linear") +
    # ggtitle(sprintf("%s", x)) +
    geom_edge_fan2(aes(width = non.self, color = non.self),
                   arrow = arrow(length = unit(3, 'mm'), type = "closed"),
                   end_cap = circle(5, 'mm')) +
    scale_edge_width(range = c(1, 2)) +
    scale_edge_color_gradient2(
      # low = "#D1D1D1",
      low = "#dadada",
      high = "black",
      mid = "#616161",
      midpoint = .5
    ) +
    geom_node_label(aes(label = nodeName, fill = self),
                    color = "white", repel = FALSE, size = 5,
                    label.padding = unit(0.1, "lines")) +
    scale_fill_gradient2(
      # low = "blue",
      low = "#009fe3",
      mid = "black",
      # high = "red",
      high = "#e71d73",
      midpoint = .5
    ) +
    theme_graph(
      plot_margin = margin(0,0,0,0),
      border = TRUE,
      background = NA
    ) +
    theme(
      legend.position = "none",
      plot.title = element_text(size = 6, family = "Arial"),
      plot.margin = unit(c(3,3,3,3), 'mm'), 
    )

  ggsave(file = file.path(anaDir, "networks", paste0("network_", x, ".pdf")),
         width = 2.2, height = 2.2, dpi = 400, bg = "transparent")
}

# ggpubr::ggarrange(plotlist = pList, nrow = 1)

# https://stackoverflow.com/a/17075381
# ggsave(file = file.path(anaDir, "total_networks.tiff"),
# ggsave(file = file.path(anaDir, "total_networks_GCAMP.tiff"),
  # width = 7, height = 2)
  # width = 20, height = 3.5)
  # width = 25, height = 2)
```

```{r fig_clusters_freq, fig.height=4, fig.width=15}
# save frequencies of track clusters
summaryDF <- copy(tcells.sc)

summaryDF <- .mapClustNames(summaryDF, clusterMapping, "clusters")

# show frequency of clusters
# summaryDF <- summaryDF[, .(n.clusters = .N), by = .(uID, pop, clusters)] %>%
# summaryDF <- summaryDF[, .(n.clusters = .N), by = .(uID, pop, clusters.name, clusters.id)] %>%
summaryDF <- summaryDF[clusters.name != "Aggregating", .(n.clusters = .N), by = .(uID, pop, clusters.name, clusters.id)] %>%
# summaryDF <- summaryDF[!clusters %in% c(3), .(n.clusters = .N), by = .(uID, pop, clusters)] %>%
# summaryDF <- summaryDF[, .(n.clusters = .N), by = .(uID, pop, clusters.name)] %>%
# summaryDF <- summaryDF[clusters.name != "Clustering", .(n.clusters = .N), by = .(uID, pop, clusters.name)] %>%
  droplevels() %>%
  group_by(uID, pop) %>%
  mutate(freq.clusters = n.clusters/sum(n.clusters) * 100) %>%
  ungroup() %>%
  # complete(uID, pop, clusters, fill = list(freq.clusters = 0)) %>%
  complete(uID, pop, clusters.id, fill = list(freq.clusters = 0)) %>%
  left_join(exp.info)

# summaryDF$clusters <- factor(summaryDF$clusters, levels = c(3,6,0,7,2,5,4))

# ggplot(summaryDF, aes(clusters, freq.clusters, color = interaction(Treatment, DTx))) +
ggplot(summaryDF, aes(clusters.name, freq.clusters, color = interaction(Treatment, DTx))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(
    position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  scale_color_brewer(name = "Treatment", palette = "Set1") +
  facet_grid(.~pop)

ggsave(file.path(anaDir, "clusters_freq.pdf"), width = 14, height = 3)
# ggsave(file.path(anaDir, "clusters_freq_wo_clusters.pdf"), width = 14, height = 3)

summaryDF$Treatment.DTx <- 0
summaryDF[summaryDF$Treatment == "PBS" & summaryDF$DTx == "PBS",]$Treatment.DTx <- 0
summaryDF[summaryDF$Treatment == "HSV" & summaryDF$DTx == "PBS",]$Treatment.DTx <- 1
summaryDF[summaryDF$Treatment == "HSV" & summaryDF$DTx == "DTx",]$Treatment.DTx <- 2

summaryDF$cell_id <- 0
summaryDF[summaryDF$pop == "tcells.gDT/tracked",]$cell_id <- 1

# data.table::fwrite(summaryDF %>% drop_na(clusters) %>% dplyr::filter(cell_id == 0),
data.table::fwrite(summaryDF %>% drop_na(clusters.id) %>% dplyr::filter(cell_id == 0),
          # file = file.path(anaDir, "freq_clusters_gBT.csv"))
          file = file.path(anaDir, "freq_clusters_gBT_wo_clusters.csv"))
# data.table::fwrite(summaryDF %>% drop_na(clusters) %>% dplyr::filter(cell_id == 1),
data.table::fwrite(summaryDF %>% drop_na(clusters.id) %>% dplyr::filter(cell_id == 1),
          # file = file.path(anaDir, "freq_clusters_gDT.csv"))
          file = file.path(anaDir, "freq_clusters_gDT_wo_clusters.csv"))

data.table::fwrite(summaryDF, file = file.path(anaDir, "freq_clusters.csv"))
```

```{r fig_gDT_behaviour, fig.height=4, fig.width=6}
# with which cell types are these clusters in contact?
popDTs[popDTs[pop == "tcells.gBT/tracked", c("uID", "label", "track_id")],
       on = c("uID", "live.cell.contact_id#live.tcells.gBT/tracked" = "label"),
       contact.track := i.track_id]

popDTs[tcells.sc[pop == "tcells.gBT/tracked", c("uID", "track_id", "clusters")],
       on = c("uID", "contact.track" = "track_id"),
       contact.clusters := i.clusters]
```


```{r fig_gDT_behaviour, fig.height=3, fig.width=12}
clusterContacts <- popDTs %>%
  left_join(tcells.sc)

clusterContacts$contact.cell.cluster <- FALSE
clusterContacts[clusterContacts$contact.clusters == 3, ]$contact.cell.cluster <- TRUE

# get percentage of track in contact with clusters
freqClustContact <- clusterContacts %>%
  group_by(uID, pop, track_id, contact.cell.cluster) %>%
  summarise(n = n()) %>%
  mutate(freq.non.contact.cell.cluster = n/sum(n) * 100) %>%
  dplyr::filter(contact.cell.cluster == FALSE)

clusterContacts <- copy(tcells.sc)

clusterContacts$clusters.name <- "NONE"
clusterContacts[clusterContacts$clusters %in% c(1,7), ]$clusters.name <- "Directed"
clusterContacts[clusterContacts$clusters %in% c(3), ]$clusters.name <- "Clustering"
clusterContacts[clusterContacts$clusters %in% c(2,5,6), ]$clusters.name <- "Meandering"
clusterContacts[clusterContacts$clusters %in% c(0,4), ]$clusters.name <- "Scanning"

clusterContacts <- clusterContacts %>%
  dplyr::filter(clusters.name != "NONE", pop == "tcells.gDT/tracked") %>%
  left_join(freqClustContact)

clusterContacts$contact.cell.cluster <- FALSE
clusterContacts[clusterContacts$freq.non.contact.cell.cluster < 100, ]$contact.cell.cluster <- TRUE

clusterContacts <- clusterContacts %>%
  # group_by(uID, pop, clusters, contact.clusters) %>%
  group_by(uID, pop, contact.cell.cluster, clusters) %>%
  # group_by(uID, pop, contact.cell.cluster, clusters.name) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n) * 100) %>%
  ungroup() %>%
  complete(
    uID, contact.cell.cluster, clusters,
    # uID, contact.cell.cluster, clusters.name,
    fill = list(freq = 0)) %>%
  left_join(exp.info)

ggplot(clusterContacts, 
       # aes(as.factor(clusters), freq.contact.clusters,
       aes(as.factor(clusters), freq, color = interaction(Treatment, DTx))) +
       # aes(as.factor(clusters.name), freq, color = interaction(Treatment, DTx))) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
  ylab("Behaviour (%)") + xlab("gDT cluster") + ylim(0, 100) +
  scale_color_brewer(name = NULL, palette = "Set1") +
  facet_grid(.~contact.cell.cluster)

ggsave(file.path(anaDir, "gDT_behaviour_visiting_gBT_cluster.png"), height = 2, width = 12)
```

