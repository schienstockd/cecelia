---
title: "Behaviour GCAMP"
output: html_document
date: '2022-08-15'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Show transition states of live cell imaging

```{r}
Sys.setenv(KMP_DUPLICATE_LIB_OK = "TRUE")
devtools::load_all("../")
cciaUse("~/cecelia/dev")

library(ggplot2)
library(tidyverse)
```

```{r}
# set test variables
pID <- "CV5iNI"
# pID <- "uh0h3c"
# pID <- "8BR53W"
versionID <- 1
projectsDir <- "/Volumes/USER/Dominik/cecelia/projects/"
hpcDir <- "/data/scratch/projects/punim1124/cecelia/USER_data/schienstockd/"
```

```{r}
# anaDir <- "/Volumes/USER_data/Dominik/Experiments/DS_N101/ANALYSIS/CECELIA/"
anaDir <- "/Volumes/USER_data/Dominik/Experiments/3P_TEST/Tissues"
```

```{r}
# HPC config
HPC_CONF <-  list(
  hpc = list(
    conf = list(
      email = "schienstockd@student.unimelb.edu.au",
      emailOnBegin = FALSE,
      emailOnEnd = FALSE,
      emailOnFail = TRUE,
      numNodes = 1,
      numTasks = 1,
      numCPUperTask = 1,
      numGPUperTask = 1,
      memory = 50,
      walltime = "00-02:00:00",
      projectPartitions = "gpu-a100",
      projectID = "punim1031",
      projectQos = "",
      useGPU = TRUE
    )
  ),
  utils = list(
    ssh = list(
      username = "schienstockd",
      address = "spartan.hpc.unimelb.edu.au",
      keyfile = "/Users/Dominik/.ssh/spartan_rsa"
    ),
    python = list(
      condaEnv = cciaConf()$python$conda$source$env,
      condaDir = cciaConf()$python$conda$dir
    )
  )
)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# upload local files
funParams <- list(
  # trainingSetID = "oe6kuP", # Tomato
  # trainingSetID = "91Kd1K", # XCR1
  # trainingSetID = "q4Hxd3", # Tom AF corrected
  trainingSetID = "fIuYJG", # TEST
  # numTrainingImages = 20,
  numTrainingImages = 10,
  maximumProjection = FALSE,
  removePrevious = TRUE,
  # imSource = "default",
  imSource = "afCorrected",
  channels = c(6),
  crop = list(X = 2048, Y = 2048, Z = 8, T = 1)
)

# init ccia object
cciaObj <- initCciaObject(
  # pID = pID, uID = "fmjlDg", versionID = versionID, initReactivity = FALSE # SHG 3P
  pID = pID, uID = "ecnsNw", versionID = versionID, initReactivity = FALSE # Tissues
)

# channel 7 for Tomato, 14 for XCR1
# funParams$channels <- c(6)
# funParams$channels <- c(13)
# uIDs <- c("Npsfli", "0QQl59", "vW8BC1", "n48TTE", "tK0DVg")

# channel 3 for Tomato, 10 for XCR1
# funParams$channels <- c(2)
# funParams$channels <- c(9)
# uIDs <- c("RJsT1v", "tP38h2")

# AF correction test
funParams$channels <- c(2)
# uIDs <- c("RJsT1v", "tP38h2")
uIDs <- c("Ktys8X")

cciaObj$runTasks(
  funName = "trainModels.generateTrainingImages",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1,
  uIDs = uIDs,
  mc.cores = 3
)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "0hkIKC", versionID = versionID, initReactivity = FALSE 
)

cciaObj$setImLabelsFilepath("gBT.h5ad", valueName = "gBT")
cciaObj$setImLabelsFilepath("OTI.h5ad", valueName = "OTI")
cciaObj$setImLabelPropsFilepath("gBT.zarr", valueName = "gBT")
cciaObj$setImLabelPropsFilepath("OTI.zarr", valueName = "OTI")
cciaObj$saveState()
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "6p8l06", versionID = versionID, initReactivity = FALSE 
)

exp.info <- as.data.table(cciaObj$summary(
  withSelf = FALSE, fields = c("Attr")
))

cciaObj <- initCciaObject(
  pID = pID, uID = "fYyXay", versionID = versionID, initReactivity = FALSE 
)

clustDT <- cciaObj$popDT(popType = "clust", includeFiltered = TRUE)
```

```{r fig_umap, fig.height=3, fig.width=5}
# plot clustering
datToPlot <- clustDT %>%
  # group_by(uID, value_name, pop) %>%
  group_by(uID, value_name, clusters) %>%
  summarise(n = n()) %>%
  mutate(freq = n/sum(n)) %>%
  ungroup() %>%
  complete(uID, value_name, clusters, fill = list(freq = 0)) %>%
  left_join(exp.info) %>%
  dplyr::filter(!uID %in% c("lNh9nD", "AEL4yM"))

# ggplot(datToPlot, aes(pop, freq, color = value_name)) +
ggplot(datToPlot, aes(clusters, freq, color = value_name)) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0.) +
  geom_jitter(
    position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0) +
    # width = 0.2, alpha = 0.4) +
  facet_grid(.~DTx) +
  # coord_flip() +
  # xlab("") + ylab("freq") +
  theme(
    # axis.text.x = element_blank(),
    # axis.ticks.x = element_blank(),
    # strip.background = element_blank(),
    # strip.text.x = element_blank(),
  )

# ggsave(file.path(anaDir, "tracking", "iLN", "depth-speeds.png"), height = 1.5, width = 4)
```


```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "fYyXay", versionID = versionID, initReactivity = FALSE
)

popType <- "clust"

# get all populations
# pops <- cciaObj$popPaths(popType, includeFiltered = TRUE)
pops <- NULL
includeFiltered <- TRUE
flushCache <- TRUE
purge <- TRUE

popCols <- c(cciaObj$imChannelNames()[1], "track_id", "clusters", "valueName")

# cciaObj$popPaths(popType, includeFiltered = includeFiltered)

# save populations
cciaObj$savePops(
  popType, c("A", "B"), purge = purge,
  includeFiltered = TRUE, tracksOnly = TRUE)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "AEL4yM", versionID = versionID, initReactivity = FALSE
)

cciaObj$setImLabelsFilepath("gBT.zarr", valueName = "gBT")
cciaObj$setImLabelPropsFilepath("gBT.h5ad", valueName = "gBT")
cciaObj$setImLabelsFilepath("OTI.zarr", valueName = "OTI")
cciaObj$setImLabelPropsFilepath("OTI.h5ad", valueName = "OTI")
cciaObj$saveState()
```


```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "tK0DVg", versionID = versionID, initReactivity = FALSE
)

# train model for image restoration
funParams <- list(
  valueName = "default",
  stripePerc = 20,
  imChannels = c("ten")
)

cciaObj$runTask(
  funName = "cleanupImages.removeStripes",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  # pID = pID, uID = "oe6kuP", versionID = versionID, initReactivity = FALSE # Tomato
  # pID = pID, uID = "91Kd1K", versionID = versionID, initReactivity = FALSE # XCR1
  pID = pID, uID = "q4Hxd3", versionID = versionID, initReactivity = FALSE # Tomato AF
)

cciaObj$persistentObjectDirectory(root = TRUE)
      
# train model for image restoration
funParams <- list(
  imSource = "ccidImage.zarr",
  uIDs = names(cciaObj$cciaObjects()),
  patchXY = 64,
  patchZ = 4,
  trainEpochs = 20,
  modelAuthors = "Dominik",
  # valueName = "3P_Tomato_v1",
  # modelName = "3P Tomato v1",
  # modelDesc = "3P Tomato model v1"
  # valueName = "3P_XCR1_v1",
  # modelName = "3P XCR1 v1",
  # modelDesc = "3P XCR1 model v1"
  valueName = "3P_Tomato_AF_v1",
  modelName = "3P Tomato AF v1",
  modelDesc = "3P Tomato AF model v1"
)

cciaObj$runTask(
  funName = "trainModels.trainN2V",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  # pID = pID, uID = "faPUoZ", versionID = versionID, initReactivity = FALSE # test
  # pID = pID, uID = "Npsfli", versionID = versionID, initReactivity = FALSE # 4D 3P test
  pID = pID, uID = "RJsT1v", versionID = versionID, initReactivity = FALSE # 4D 3P test
)

# train model for image restoration
funParams <- list(
  valueName = "default",
  modelMapping = list(
    `3P_Tomato_v1` = list(
      # modelChannels = c("seven", "eleven", "fifteen"),
      modelChannels = c("three", "seven", "eleven"),
      normPerc = 99.99
    ),
    `3P_XCR1_v1` = list(
      # modelChannels = c("fourteen"),
      modelChannels = c("ten"),
      normPerc = 99.99
    )
  )
)

cciaObj$runTask(
  funName = "cleanupImages.n2vCorrect",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```



```{r}
# write uIDs list for python
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  # pID = pID, uID = "oe6kuP", versionID = versionID, initReactivity = FALSE # SHG 3P
  pID = pID, uID = "91Kd1K", versionID = versionID, initReactivity = FALSE # SHG 3P
)

paste(names(cciaObj$cciaObjects()), collapse = "', '")
```


```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# upload local files
funParams <- list(
   valueName = "tcells.B6",
   maxSearchRadius = 10,
   maxLost = 3,
   accuracy = 0.8,
   probToAssign = 0.8,
   noiseInital = 300,
   noiseProcessing = 100,
   noiseMeasurements = 100,
   distThresh = 10,
   timeThresh = 5,
   segmentationMissRate = 0.1,
   lambdaLink = 5,
   lambdaTime = 5,
   lambdaDist = 5,
   thetaTime = 5,
   thetaDist = 5,
   minTimepoints = 5,
   minDisplacement = 10,
   maxMeanTurningAngle = 0,
   filters = list(
     a = list(
       measure = c("surface_to_volume"),
       values = c("1.2"),
       fun = c("lte")
     )
   ),
   calcTrackingStats = TRUE
)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "42xBGe", versionID = versionID, initReactivity = FALSE # SHG 3P
)

cciaObj$setImLabelsFilepath("tcells.B6.zarr", valueName = "tcells.B6")
cciaObj$setImLabelPropsFilepath("tcells.B6.h5ad", valueName = "tcells.B6")
cciaObj$saveState()

cciaObj$runTask(
  funName = "tracking.bayesianTracking",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "DHiI67", versionID = versionID, initReactivity = FALSE # SHG 3P
)

funParams <- list(
   valueName = "P14-CTDR",
   pops = c("P14-CTDR/tracked")
)

cciaObj$runTask(
  funName = "segment.binariseTracks",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "4li7ih", versionID = versionID, initReactivity = FALSE # SHG 3P
)

popDT <- cciaObj$popDT("labels", pops = c("OTI"))

max(popDT$centroid_x)
max(popDT$centroid_y)
max(popDT$centroid_z)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "EYaott", versionID = versionID, initReactivity = FALSE
)

pops <- c("tcells/tracked")
popDT <- cciaObj$popDT("live", pops = pops, includeFiltered = TRUE)

# get tracks info and check parameters
tracksInfo <- cciaObj$tracksMeasures(pops = pops)
```

```{r fig_umap, fig.height=3, fig.width=4}
# plot speeds
ggplot(tracksInfo, aes(as.factor(1), speed)) +
  theme_classic() +
  geom_jitter(
    # position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0)
    width = 0.2, alpha = 0.4) +
  geom_boxplot(outlier.alpha = 0.) +
  xlab("") + ylab("Velocity (μm/min)") +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(),
    strip.text.x = element_blank(),
  ) +
  expand_limits(y = 0)
```

```{r fig_umap, fig.height=3, fig.width=4}
# plot speeds
ggplot(tracksInfo, aes(as.factor(1), speed)) +
  theme_classic() +
  geom_jitter(
    # position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0)
    width = 0.2, alpha = 0.4) +
  geom_boxplot(outlier.alpha = 0.) +
  xlab("") + ylab("Velocity (μm/min)") +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(),
    strip.text.x = element_blank(),
  ) +
  expand_limits(y = 0)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  # pID = pID, uID = "IksEJv", versionID = versionID, initReactivity = FALSE # SHG 3P
  # pID = pID, uID = "8nDQV9", versionID = versionID, initReactivity = FALSE # SHG 3P
  # pID = pID, uID = "42xBGe", versionID = versionID, initReactivity = FALSE # SHG 3P
  # pID = pID, uID = "DHiI67", versionID = versionID, initReactivity = FALSE # SHG 3P
  # pID = pID, uID = "wX74z9", versionID = versionID, initReactivity = FALSE # SHG 3P
  # pID = pID, uID = "4li7ih", versionID = versionID, initReactivity = FALSE # Tumour 3P
  # pID = pID, uID = "4i3bxX", versionID = versionID, initReactivity = FALSE # vessels Cornea
  # pID = pID, uID = "b9o98P", versionID = versionID, initReactivity = FALSE # vessels Cornea
  # pID = pID, uID = "INglID", versionID = versionID, initReactivity = FALSE # CD11c 2P
  # pID = pID, uID = "nu0Nmo", versionID = versionID, initReactivity = FALSE # T cell types
   # Tissues
)

# get vector information to plot anisotropy
# unsLabels <- c("SHG", "P14-CTDR.tracks")
# unsLabels <- c("SHG", "gBT.tracks")
# uns <- list()
# 
# for (i in unsLabels) {
#   labels <- cciaObj$labelProps(valueName = paste0(i, ".branch"))
#   # labels <- cciaObj$labelProps(valueName = "vessels.branch")
#   # labels <- cciaObj$labelProps(valueName = "CD11c.branch")
#   uns[[i]] <- labels$values_uns()
#   labels$close()
# }
# 
# # get branching
# branchDT <- cciaObj$popDT("branch")

pops <- list(
  # tcells.ubiTom = "tcells.ubiTom/tracked",
  # tcells.B6 = "tcells.B6/tracked"
  # `P14-Tom` = "P14-Tom/tracked",
  # `P14-CTDR` = "P14-CTDR/tracked"
  # `gBT` = "gBT/tracked"
  `Tcells` = "default/tracked"
  # `P14` = "P14/tracked"
)

uIDs <- names(cciaObj$cciaObjects())
uIDs <- c("z4O95Y", "JIuGbT", "OnH3TR")

# get tracks to align with SHG
# popDT <- cciaObj$popDT("live", pops = "P14-CTDR/tracked", includeFiltered = TRUE)
# popDT <- cciaObj$popDT("live", pops = c(
#   "tcells.OTI/tracked",
#   "tcells.P14/tracked",
#   "tcells.gBT/tracked"
# ), includeFiltered = TRUE)
popDT <- cciaObj$popDT("live", pops = pops, includeFiltered = TRUE, uIDs = uIDs)

# get tracks info and check parameters
# tracksInfo <- cciaObj$tracksMeasures(pops = "P14-CTDR/tracked")
tracksInfo <- cciaObj$tracksMeasures(pops = pops)

# # get clustering
# tcells.sc <- as.data.table(cciaEnv()$LabelPropsUtils(
#   cciaObj$persistentObjectDirectory(uID = "fmjlDg"),
#   value_name = "tracks.clusters.tcells.default.sc")$label_props_view()$as_df())
#   # value_name = "tracks.clusters.tcells.hmm_movement.sc")$label_props_view()$as_df())
```

```{r fig_umap, fig.height=3, fig.width=4}
# plot speeds
tracksInfo[, uID := factor(uID, levels = c("z4O95Y", "JIuGbT", "OnH3TR"))]

ggplot(tracksInfo, aes(as.factor(1), speed)) +
  theme_classic() +
  geom_jitter(
    # position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0)
    width = 0.2, alpha = 0.4) +
  geom_boxplot(outlier.alpha = 0.) +
  facet_grid(.~depth) +
  # coord_flip() +
  xlab("") + ylab("Velocity (μm/min)") +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(),
    strip.text.x = element_blank(),
  )

ggsave(file.path(anaDir, "tracking", "iLN", "depth-speeds.png"), height = 1.5, width = 4)
```


```{r}
# plot quiver
coords <- lapply(uns, function(x) {
  coords <- data.frame(
    y = as.vector(x$ilee_coor_list[1,,,1]),
    x = as.vector(x$ilee_coor_list[1,,,2])
  )
  u <- as.vector(x$ilee_eigval[1,,,2]) * as.vector(x$ilee_eigvec[1,,,2,1])
  v <- as.vector(x$ilee_eigval[1,,,1]) * as.vector(x$ilee_eigvec[1,,,1,1])
  
  list(coords = coords, u = u, v = v)
})
```

```{r}
# get average direction and velocity for cells
gridWindow <- 40

tracksSpots <- expand.grid(
  seq(0, cciaObj$omeXMLPixels()$SizeX, gridWindow),
  seq(0, cciaObj$omeXMLPixels()$SizeY, gridWindow)
)
colnames(tracksSpots) <- c("X", "Y")

# get mean orientation
shiftCols <- c("centroid_x", "centroid_y")
shiftColsNames <- paste("lag", shiftCols, sep = ".")

# https://stackoverflow.com/a/26292059
popDT[, (shiftColsNames) := shift(.SD), by = .(pop, track_id), .SDcols = shiftCols]

# https://stackoverflow.com/a/24747155
euc.dist <- function(x1, x2) sqrt(sum((x1 - x2) ^ 2))

popDT[, `:=` (
  delta_centroid_x = centroid_x - lag.centroid_x,
  delta_centroid_y = centroid_y - lag.centroid_y
  )] 

popDT[, centroid_dist := euc.dist(
  c(centroid_x, centroid_y), c(lag.centroid_x, lag.centroid_y)), by = 1:nrow(popDT)]
```

```{r}
# get average vector fields
popDT[, centroid_region := as.numeric(NA)]

# get closest spots
popDT[, centroid_region := dbscan::kNN(
  as.matrix(tracksSpots), k = 1, query = as.matrix(popDT[, c("centroid_x", "centroid_y")]))$id]
```

```{r fig_umap, fig.height=10, fig.width=10}
# can you show the branching patterns on a plot?
# p1 <- ggplot(branchDT[pop != "P14-CTDR.tracks.branch"]) + 
p1 <- ggplot(branchDT[pop != "gBT.tracks.branch"]) + 
  # scale_color_brewer(palette = "Set1") +
  theme_classic() +
  plotThemeDark() +
  coord_fixed() +
  xlim(0, cciaObj$omeXMLPixels()$SizeX) +
  ylim(cciaObj$omeXMLPixels()$SizeY, 0) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  ) 

p1 + geom_segment(aes(
  x = `coord-src-2`, y = `coord-src-1`,
  xend = `coord-dst-2`, yend = `coord-dst-1`,
  color = as.factor(`label`))) +
  # color = as.factor(`branch-type`)),
  # size = 1, color = "#4682b4", alpha = 1) +
  geom_path(
    data = popDT[value_name == names(pops)[[1]]], aes(centroid_x, centroid_y, group = track_id),
    # color = "#ebd441", size = 1.5, alpha = 1) +
    color = "#AA1F5E", size = 1.5, alpha = 1)
  # geom_path(
  #   data = popDT[value_name == names(pops)[[2]]], aes(centroid_x, centroid_y, group = track_id),
  #   color = "#AA1F5E", size = 1.5, alpha = 1) +
  # ggquiver::geom_quiver(
  #   data = coords$SHG$coords, aes(x = x, y = y, u = -coords$SHG$u, v = coords$SHG$v), color = "white", size = 1.2)
  # ggquiver::geom_quiver(
  #   data = coords[[2]]$coords, aes(x = x, y = y, u = -coords[[2]]$u, v = coords[[2]]$v), color = "#AA1F5E", size = 1)

# ggsave(file.path(anaDir, paste0("SHG_tracking_field-", cciaObj$getUID(), ".pdf")),
# ggsave(file.path(anaDir, paste0("SHG_tracking_field-tracks-", cciaObj$getUID(), ".pdf")),
       # height = 8, width = 8)
```

```{r}
# get angles relative to T cells and structures
tracks.i <- "P14-CTDR.tracks"
vecDiffs <- list()

for (i in names(coords)[names(coords) != tracks.i]) {
  vecDiffs[[i]] <- c()
  
  for(j in seq(length(coords[[i]]$u))) {
    matA <- matrix(c(coords[[tracks.i]]$u[[j]], coords[[tracks.i]]$v[[j]]), nrow = 2)
    matB <- matrix(c(coords[[i]]$u[[j]], coords[[i]]$v[[j]]), nrow = 2)
    vecDiffs[[i]] <- c(vecDiffs[[i]], 180 - matlib::angle(as.vector(matA), as.vector(matB)))
  }
}
```

```{r fig_umap, fig.height=10, fig.width=10}
# plot out difference in angle
# https://stackoverflow.com/a/39923381
structNames <- names(coords)[names(coords) != tracks.i]
diffsDT <- as.data.table(cbind(coords$SHG$coords, vecDiffs))
diffsDT[is.na(diffsDT), ] <- 0 
diffsDT[, max := colnames(.SD)[max.col(.SD, ties.method = "first")], .SDcols = structNames]
diffsDT[SHG == 0, max := NA]

p1 <- ggplot(diffsDT, aes(x, y)) +
  theme_classic() +
  plotThemeDark() +
  coord_fixed() +
  xlim(-10, cciaObj$omeXMLPixels()$SizeX + 10) +
  ylim(cciaObj$omeXMLPixels()$SizeY + 10, -10) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )

for (i in structNames) {
   p2 <- p1 + geom_tile(aes(fill = get(i)), colour = "black", size = 0.5) +
    # viridis::scale_fill_viridis(
    #   breaks = c(0, 180), labels = c(0, 180), na.value = "black") +
    scale_fill_gradient2(low="blue", high="red", mid = "white", midpoint = 90) +
    ggquiver::geom_quiver(
      data = coords$`P14-CTDR.tracks`$coords, aes(x = x, y = y, u = -coords$`P14-CTDR.tracks`$u, v = coords$`P14-CTDR.tracks`$v),
      color = "white", size = 1)
  
  ggsave(file.path(anaDir, paste0("angle-", i, "-", cciaObj$getUID(), ".pdf")),
       height = 10, width = 10, plot = p2)
}

# plot most prominent class
p2 <- p1 + geom_tile(aes(fill = max), colour = "black", size = 0.5) +
  scale_fill_brewer(palette = "Set2") +
  ggquiver::geom_quiver(
    data = coords$`P14-CTDR.tracks`$coords, aes(x = x, y = y, u = -coords$`P14-CTDR.tracks`$u, v = coords$`P14-CTDR.tracks`$v),
    color = "white", size = 1) +
  theme(legend.position = "bottom")

ggsave(file.path(anaDir, paste0("angle-max-", cciaObj$getUID(), ".pdf")),
     height = 10, width = 10, plot = p2)
```


```{r fig_umap, fig.height=10, fig.width=20}
tracksMeasures <- colnames(tracksInfo)
tracksMeasures <- tracksMeasures[!tracksMeasures %in% c("cell_type", "track_id")]

tracksMeasuresDT <- popDT[tracksInfo, on = c("value_name" = "cell_type", "track_id")]

p1s <- list()
for (i in tracksMeasures) {
  local({
    local_i <- i
    
    p1s[[local_i]] <<- p1 + 
      ggquiver::geom_quiver(
        data = coords, aes(x = x, y = y, u = -u, v = v), color = "white", size = 1) +
      geom_path(
      # p1s[[local_i]] <<- p1 + geom_bin_2d(
        data = tracksMeasuresDT, 
        aes(centroid_x, centroid_y, group = interaction(value_name, track_id), color = get(local_i)),
        # aes(centroid_x, centroid_y, group = track_id, fill = get(local_i)),
        size = 1.5) +
      viridis::scale_color_viridis() +
      # viridis::scale_fill_viridis() +
      ggtitle(local_i) 
    
    ggsave(
      file.path(anaDir, paste0("SHG_tracking_field-", local_i, "-", cciaObj$getUID(), ".pdf")),
      height = 8, width = 8, plot = p1s[[local_i]])
  })
}

# ggpubr::ggarrange(plotlist = p1s, ncol = 5, nrow = 2)
```

```{r}
# can you correlate anisotropy with tracks?
coordsX <- uns$ilee_coor_list[1,,,2]
coordsY <- uns$ilee_coor_list[1,,,1]
dim(coordsX) <- NULL
dim(coordsY) <- NULL
m <- cbind(coordsX, coordsY)

# get anisotropy for each spot in track
popDT$aniso.id <- dbscan::kNN(m, k = 1, query = popDT[, c("centroid_x", "centroid_y")])$id
popDT$aniso.box <- uns$ilee_box_anisotropy[popDT$aniso.id]
```

```{r fig_track_aniso, fig.height=10, fig.width=15}
# plot all combinations of measurements with anisotropy
datToPlot <- as.data.table(popDT %>%
  group_by(track_id) %>%
  summarise(mean.aniso.box = mean(aniso.box)))[tracksInfo, on = c("track_id")] %>%
  # pivot_longer(cols = c(measures, "mean.aniso.box"),
  pivot_longer(cols = tracksMeasures,
               names_to = "measure", values_to = "value")

ggplot(datToPlot, aes(mean.aniso.box, value)) +
# ggplot(datToPlot, aes(weighted.aniso.box, value, color = uID)) +
  theme_classic() +
  geom_point(shape = 1, stroke = 1) +
  facet_wrap(.~measure, ncol = 4, scales = "free_y") +
  xlab("Close to anisotropy with % of") +
  scale_color_brewer(palette = "Set2") +
  expand_limits(x = 0, y = 0) +
  # xlim(0, 50) +
  theme(
    legend.title = element_blank(),
    legend.position = "bottom",
    legend.justification = "left"
  )
```

```{r}
library(ggquiver)

# plot quiver
coords <- expand.grid(
  y = uns$ilee_coor_list[1,,,,2][1,,][,1],
  x = uns$ilee_coor_list[1,,,,3][,1,][1,])
u <- as.vector(uns$ilee_eigval[1,,,,1][1,,]) * as.vector(uns$ilee_eigvec[1,,,,,1][,,,1][1,,])
v <- as.vector(uns$ilee_eigval[1,,,,2][1,,]) * as.vector(uns$ilee_eigvec[1,,,,,2][,,,1][1,,])

# coor_list[:,:,1].flatten(),
# coor_list[:,:,0].flatten(),
# eigval[:,:,1].flatten() * eigvec[:,:,1,0].flatten(),
# eigval[:,:,0].flatten() * eigvec[:,:,0,0].flatten(),
# color = 'red'
ggplot(coords, aes(x = x, y = -y, u = u, v = v)) +
  geom_quiver() +
  theme_classic() +
  coord_fixed()
```


```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  # pID = pID, uID = "DHiI67", versionID = versionID, initReactivity = FALSE 
  pID = pID, uID = "DkSYMM", versionID = versionID, initReactivity = FALSE 
)

# branchDT <- as.data.table(cciaObj$labelProps(valueName = "SHG.branch")$as_df())

# get DTs
branchDT <- cciaObj$popDT(
  "branch", includeFiltered = TRUE, completeDT = TRUE,
  completeValueNames = "SHG.branch",
  pops = unlist(unname(cciaObj$popPaths("branch", includeFiltered = TRUE, includeRoot = FALSE))))
# popDT <- cciaObj$popDT("live", includeFiltered = TRUE, pops = "P14-CTDR/tracked")
popDT <- cciaObj$popDT("live", includeFiltered = TRUE, pops = "OTI/tracked")
```

```{r}
# now build a weighted graph of the most visited edges and save back to branchDT
# then you can use that to display on the image
x <- as.matrix(branchDT[, c('centroid_z', 'centroid_y', 'centroid_x')])
rownames(x) <- branchDT$label

# find nearest neighbours
popNN <- dbscan::kNN(
  x, k = 1, query = as.matrix(popDT[, c('centroid_z', 'centroid_y', 'centroid_x')]))

# filter long distances
# regionVals <- regionDT[popNN$id, ]$regions
# regionVals <- branchDT[popNN$id, ]$`branch-type`
popDT[, branch.id := popNN$id]
popDT[, branch.dist := popNN$dist]
popDT[branchDT[, c("label", "branch-type")], on = c("branch.id" = "label"),
      `branch-type` := `branch-type`]
```

```{r}
unique(popDT[branch.dist < maxDist, c("branch.id", "track_id")])

(unique(popDT[branch.dist < maxDist, c("branch.id", "track_id")]) %>%
  dplyr::group_by(branch.id) %>%
  summarise(n = n()))$n
```


```{r}
# get frequency of T cells close to branches
maxDist <- 10
branchDT[, weight := 0]
branchDT[label %in% unique(popDT[branch.dist < maxDist]$branch.id), weight := table(popDT[branch.dist < maxDist, c("branch.id")])]

weightUp <- quantile(branchDT$weight, 0.99)
branchDT[weight > weightUp, weight := weightUp] 

branchDT$weight
```

```{r fig_pop_branching, fig.height=5, fig.width=5}
ggplot(branchDT, aes(centroid_x, -centroid_y, color = weight)) +
  theme_classic() +
  geom_point(size = 0.5) +
  viridis::scale_colour_viridis() +
  coord_fixed() +
  expand_limits(y = 0, x = 0) +
  plotThemeDark()

ggsave(file.path(anaDir, "weights.png"), width = 5, height = 5)
```

```{r}
# HMM
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  # pID = pID, uID = "IksEJv", versionID = versionID, initReactivity = FALSE # Tcells
  pID = pID, uID = "DkSYMM", versionID = versionID, initReactivity = FALSE # Tcells
)

# run task
funParams <- list(
  popType = "live",
  valueName = "SHG",
  # pops = c("P14-CTDR/tracked"),
  pops = c("OTI/tracked"),
  maxDist = 5,
  upperPercentile = 99.5
)

# run task
task <- cciaObj$runTask(
  funName = "spatialAnalysis.networkWeights",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "IksEJv", versionID = versionID, initReactivity = FALSE 
)

# run task
funParams <- list(
  valueName = "driftCorrected",
  imChannels = c("P14-Tomato", "P14-CTDR"),
  slidingWindow = 10,
  createNewChannels = TRUE
)

task <- cciaObj$runTask(
  funName = "cleanupImages.slidingWindowCorrect",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```


```{r}
# HMM
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "QJYqa7", versionID = versionID, initReactivity = FALSE # Tcells
)

# get experimental info
exp.info <- as.data.table(cciaObj$summary(
  withSelf = FALSE, fields = c("Attr")
))
uIDs <- exp.info[Include == "Y"]$uID

# run task
funParams <- list(
  popType = "live",
  pops = c("tcells.OTI/tracked", "tcells.gBT/tracked", "tcells.P14/tracked"),
  modelMeasurements = c("live.cell.speed", "live.cell.angle"),
  scaleMeasurements = c("live.cell.speed", "live.cell.angle"),
  colName = "movement",
  appendStates = list(),
  skipTimesteps = 2,
  subtrackOverlap = TRUE,
  noiseFilterMeasurements = 5,
  postFiltering = 2,
  postIterations = 2,
  numStates = 3,
  uIDs = uIDs
)

# run task
task <- cciaObj$runTask(
  funName = "behaviourAnalysis.hmmStates",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# get HMM transitions
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "QJYqa7", versionID = versionID, initReactivity = FALSE # Tcells
)

# get experimental info
exp.info <- as.data.table(cciaObj$summary(
  withSelf = FALSE, fields = c("Attr")
))
uIDs <- exp.info[Include == "Y"]$uID

# run task
funParams <- list(
  popType = "live",
  pops = c("tcells.OTI/tracked", "tcells.gBT/tracked", "tcells.P14/tracked"),
  modelMeasurements = c("live.cell.speed", "live.cell.angle"),
  colName = "movement",
  hmmStates = c("movement"),
  includeStart = FALSE,
  includeSelfTransitions = TRUE,
  uIDs = uIDs
)

# run task
task <- cciaObj$runTask(
  funName = "behaviourAnalysis.hmmTransitions",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
# cluster tracks based on transitions
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE, projectsDir = projectsDir)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "QJYqa7", versionID = versionID, initReactivity = FALSE # Tcells
)

# get experimental info
exp.info <- as.data.table(cciaObj$summary(
  withSelf = FALSE, fields = c("Attr")
))
uIDs <- exp.info[Include == "Y"]$uID

# run task
funParams <- list(
  popType = "live",
  popsToCluster = c("tcells.OTI/tracked", "tcells.gBT/tracked", "tcells.P14/tracked"),
  valueName = "tracks.clusters.tcells.hmm_transitions_movement",
  # valueName = "tracks.clusters.tcells.hmm_movement",
  clusterColName = "hmm_transitions_movement",
  # clusterColName = "hmm_movement",
  resolution = 0.15,
  percentile = 99.9,
  trackMeasures = c(
    "speed",
    "duration",
    "trackLength",
    "meanTurningAngle",
    "displacement",
    "straightness",
    "displacementRatio",
    "outreachRatio",
    "asphericity",
    "overallAngle"
  ),
  objectMeasures = c(
    # "extent",
    # "solidity",
    # "integral_mean_curvature",
    # "ellipticity_oblate",
    # "ellipticity_prolate",
    # "ellipticity_interm_oblate",
    # "ellipticity_interm_prolate",
    # "sphericity",
    # HMM states
    "live.cell.hmm.state.movement",
    "live.cell.hmm.transitions.movement"
    ),
  nMeasures = c(
    ),
  sumMeasures = c(
    ),
  calcMeasures = list(
  ),
  addPops = c(
    ),
  calcLabelProps = TRUE,
  # usePaga = FALSE,
  usePaga = TRUE,
  pagaThreshold = 0.1,
  minTracklength = 6,
  # minTracklength = 18,
  # minTracklength = 50,
  uIDs = uIDs
)

# run task
task <- cciaObj$runTask(
  funName = "behaviourAnalysis.clusterTracks",
  funParams = funParams,
  env = "local",
  runInplace = TRUE,
  taskID = 1
)
```

```{r}
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "QJYqa7", versionID = versionID, initReactivity = FALSE # Tcells
)

# get experimental info
exp.info <- as.data.table(cciaObj$summary(
  withSelf = FALSE, fields = c("Attr")
))
uIDs <- exp.info[Include == "Y"]$uID

# get clustering
tcells.sc <- as.data.table(cciaEnv()$LabelPropsUtils(
  cciaObj$persistentObjectDirectory(),
  # value_name = "tracks.clusters.tcells.default.sc")$label_props_view()$as_df())
  value_name = "tracks.clusters.tcells.hmm_transitions_movement.sc")$label_props_view()$as_df())
  # value_name = "tracks.clusters.tcells.hmm_movement.sc")$label_props_view()$as_df())

# get popDTs for set
popDTs <- cciaObj$popDT(
  popType = "live", pops = c(
    "tcells.OTI/tracked",
    "tcells.gBT/tracked",
    "tcells.P14/tracked"
    ),
  includeFiltered = TRUE,
  # flushCache = TRUE,
  uIDs = uIDs)
```

```{r}
# show star plots
devtools::load_all("../")
cciaUse("~/cecelia/dev", initConda = FALSE)

# init ccia object
cciaObj <- initCciaObject(
  pID = pID, uID = "QJYqa7", versionID = versionID, initReactivity = FALSE # Tcells
)

tracks.list <- lapply(list(
  OTI = "tcells.OTI", gBT = "tcells.gBT", P14 = "tcells.P14"
), function(x) cciaObj$tracks(pop = x))

# get normalised tracks to plot
tracks.DT.norm <- tracks.combine.dt(lapply(
  tracks.list, function(x) tracks.apply.fun(x, celltrackR::normalizeTracks)
))
```


```{r fig_stars, fig.height=4, fig.width=5}
# focus spcific images
plot.uIDs <- c("LYDmWE", "UKrauQ")

unique(tracks.DT.norm[uID %in% plot.uIDs]$track_id)

ggplot(tracks.DT.norm[uID %in% plot.uIDs],
       aes(x, y, colour = track_id, group = track_id)) +
  geom_point(size = 0.5) +
  geom_path(size = 0.5) +
  theme_classic() +
  facet_wrap(uID~cell_type, nrow = 2) +
  theme(
    legend.position = "none",
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    axis.text.y = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks = element_blank(),
    strip.background = element_blank(),
    strip.text.x = element_blank(),
    axis.line = element_blank()
  ) + xlab("") + ylab("")

ggsave(file.path(anaDir, "stars.png"), width = 6, height = 4)
```

```{r}
# compare msd on plot
tracks.DT.msd <- tracks.combine.dt(lapply(
  tracks.list, function(x) tracks.aggregate.fun(
    x, celltrackR::squareDisplacement,
    summary.FUN = "mean.se", add.time.delta = TRUE,
    subtracks.i = 10
    )
))
```


```{r fig_msd, fig.height=3, fig.width=8}
# focus spcific images
plot.uIDs <- c("LYDmWE", "UKrauQ")

# plot
ggplot(tracks.DT.msd[uID %in% plot.uIDs],
       aes(x = i, y = mean, color = cell_type, fill = cell_type)) +
  geom_ribbon(aes(ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line() +
  labs(
    x = expression(paste(Delta, "t (steps)")),
    y = "MSD"
  ) +
  theme_classic() +
  facet_wrap(~uID, scales = "free") +
  scale_color_brewer(palette = "Set2") +
  scale_fill_brewer(palette = "Set2") +
  theme(
    legend.title = element_blank(),
    strip.background = element_blank(),
    strip.text.x = element_blank()
  )

ggsave(file.path(anaDir, "msd.png"), width = 6, height = 2)
```

```{r fig_hmm_props, fig.height=3, fig.width=3}
# show measurements of clusters to compare
colsToPlot <- rev(c(
  "angle",
  "speed",
  "compactness",
  "extent",
  "oblate",
  "prolate",
  "solidity",
  "sphericity",
  "surface_area",
  "volume"
))

# convert angle to degrees
popDTs[, live.cell.angle_deg := pracma::rad2deg(live.cell.angle)]

propsToPlot <- popDTs[exp.info, on = "uID"] %>%
  dplyr::rename(
    "speed" = "live.cell.speed",
    "angle" = "live.cell.angle_deg",
    "oblate" = "ellipticity_interm_oblate",
    "prolate" = "ellipticity_interm_prolate"
  ) %>%
  # drop_na(live.cell.hmm.state.hybrid_pop) %>%
  pivot_longer(
    cols = colsToPlot, names_to = "prop", values_to = "value"
    ) %>%
  pivot_longer(
    cols = c(
      "live.cell.hmm.state.movement"
      # "live.cell.hmm.state.shape"
    ), names_to = "hmm_type", values_to = "hmm_value"
    )

propsToPlot$prop <- factor(propsToPlot$prop, levels = colsToPlot)

# show heatmap for HMM
propsSummary <- propsToPlot %>%
  dplyr::filter(!is.na(hmm_value)) %>%
  group_by(hmm_type, hmm_value, prop) %>%
  replace_na(list(value = 0)) %>%
  summarise(mean = mean(value)) %>%
  group_by(hmm_type, prop) %>%
  mutate(freq = (mean - min(mean)) / (max(mean) - min(mean))) %>%
  arrange(-prop)

ggplot(propsSummary %>% dplyr::filter(hmm_value != "Clustering"), aes(as.factor(hmm_value), prop)) +
  theme_classic() +
  geom_tile(aes(fill = freq), colour = "white", size = 0.5) +
  viridis::scale_fill_viridis(
    breaks = c(0, 1),
    labels = c(0, 1)
  ) +
  theme(
    legend.position = "none",
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12),
    strip.background = element_blank(),
    strip.text.x = element_blank(),
    # axis.text.x = element_text(size = 12, angle = 45, hjust = 1, vjust = 1)
    ) +
  xlab("") + ylab("") +
  facet_grid(.~hmm_type)

ggsave(file.path(anaDir, "HMM_heat.pdf"), width = 2.1, height = 3)
```

```{r fig_umap, fig.height=4, fig.width=4}
dfToPlot <- copy(tcells.sc) %>% drop_na(clusters) %>% left_join(exp.info)

clusterMapping <- list(
  Directed = c(1),
  Meandering = c(0),
  Patrolling = c(2),
  Scanning = c(3)
)

dfToPlot <- .mapClustNames(dfToPlot, clusterMapping, "clusters")

# get mean positions of clusters
meanClusterPos <- dfToPlot %>%
  group_by(clusters) %>%
  # group_by(clusters.name) %>%
  summarise(
    UMAP_1 = mean(UMAP_1),
    UMAP_2 = mean(UMAP_2)
  )
dfToPlot$clusters <- factor(dfToPlot$clusters)

colPal <- randomcoloR::distinctColorPalette(length(unique(dfToPlot$clusters)))

# plot UMAP
ggplot(
  dfToPlot,
  aes(UMAP_1, UMAP_2)
  ) +
  geom_point(aes(color = clusters)) +
  # geom_point(aes(color = clusters.name)) +
  theme_classic() +
  scale_color_brewer(name = NULL, palette = "Set1") +
  # scale_color_manual(values = colPal) +
  theme(
    axis.text = element_text(size = 15),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.justification = "right",
    # legend.position = "bottom"
    legend.position = "none",
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
    ) 
  # geom_label(
  #   data = meanClusterPos,
  #   aes(label = clusters),
  #   # aes(label = clusters.name),
  #   label.size = 0.25,
  #   color = "black"
  #   )

# ggsave(file.path(anaDir, "umap.tiff"), width = 2, height = 2)
ggsave(file.path(anaDir, "umap_wo_labels.tiff"), width = 2, height = 2)
```

```{r fig_umap_props, fig.height=4, fig.width=4}
datToPlot <- copy(tcells.sc) %>%
  drop_na(clusters) %>%
  left_join(exp.info) 

# plot UMAP
ggplot(datToPlot, aes(UMAP_1, UMAP_2)) +
  theme_classic() +
  geom_point(aes(color = speed), size = 1, alpha = 1) +
  # geom_point(aes(color = meanTurningAngle), size = 1, alpha = 1) +
  viridis::scale_color_viridis() +
  theme(
    axis.text = element_text(size = 15),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.justification = "right",
    # legend.position = "bottom"
    legend.position = "none",
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
    )

ggsave(file.path(anaDir, paste0("umap_Velocity.tiff")), width = 2, height = 2)
# ggsave(file.path(anaDir, paste0("umap_Angle.tiff")), width = 2, height = 2)
```

```{r fig_umap, fig.height=4, fig.width=4}
plot.p1 <- function(df.all, df.subset) {
  plot.colours <- .flowColours(df.subset$UMAP_1, df.subset$UMAP_2, colramp = viridisLite::inferno)
  
  ggplot(df.all, aes(UMAP_1, UMAP_2)) +
    theme_classic() +
    geom_point(color = "#B3BCC2", size = 1) +
    # geom_point(data = df.subset, color = plot.colours, size = 1, alpha = 1) +
    geom_point(data = df.subset, color = "#AA1F5E", size = 1, alpha = 1) +
    theme(
      axis.text = element_text(size = 15),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      legend.justification = "right",
      # legend.position = "bottom"
      legend.position = "none",
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank()
      )
}

stainingCombinations <- stack(sapply(
  cciaObj$cciaObjects(uIDs = uIDs),
  function(x) paste(x$imChannelNames(), collapse = ",")
))
setnames(stainingCombinations, "values", "staining")
setnames(stainingCombinations, "ind", "uID")

datToPlot <- copy(tcells.sc) %>% left_join(stainingCombinations)
datToPlot$cell_type <- str_extract(datToPlot$pop, "(?<=\\.)[:alnum:]+(?=/)")
datToPlot$stain <- str_extract(
  datToPlot$staining, sprintf("%s-[:alnum:]+", datToPlot$cell_type)
  )

# # get equal number of points
# numPoints <- min(table(datToPlot[, c("uID", "pop")]))
# datToPlot <- datToPlot %>% group_by(stain) %>% slice_sample(n = numPoints)

# plot UMAP
# for (i in unique(datToPlot$stain)) {
for (i in unique(datToPlot$cell_type)) {
  # plot.p1(datToPlot, datToPlot %>% dplyr::filter(stain == i))
  plot.p1(datToPlot, datToPlot %>% dplyr::filter(cell_type == i))
  ggsave(file.path(anaDir, paste0("umap_Uninf_", i, ".tiff")), width = 2, height = 2)
}
```

```{r fig_umap_tests, fig.height=3, fig.width=3}
stainingCombinations <- stack(sapply(
  cciaObj$cciaObjects(uIDs = uIDs),
  function(x) paste(x$imChannelNames(), collapse = ",")
))
setnames(stainingCombinations, "values", "staining")
setnames(stainingCombinations, "ind", "uID")

summaryDF <- copy(tcells.sc) %>% left_join(stainingCombinations)
summaryDF$cell_type <- str_extract(summaryDF$pop, "(?<=\\.)[:alnum:]+(?=/)")
summaryDF$stain <- str_extract(
  summaryDF$staining, sprintf("%s-[:alnum:]+", summaryDF$cell_type)
  )

for (i in unique(summaryDF$stain)) {
  # plot UMAP
  ggplot(
    dfToPlot,
    aes(UMAP_1, UMAP_2)
    ) +
    theme_classic() +
    geom_point(data = summaryDF[stain != i], color = "#B3BCC2", size = 4) +
    geom_point(data = summaryDF[stain == i], color = "#AA1F5E", size = 4, alpha = 0.5) +
    theme(
      axis.text = element_text(size = 15),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      legend.justification = "right",
      # legend.position = "bottom"
      legend.position = "none",
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank()
      )
  
  ggsave(file.path(anaDir, paste0("umap_", i, ".tiff")), width = 5, height = 5)
}
```

```{r fig_umap_tests, fig.height=3, fig.width=3}
stainingCombinations <- stack(sapply(
  cciaObj$cciaObjects(uIDs = uIDs),
  function(x) paste(x$imChannelNames(), collapse = ",")
))
setnames(stainingCombinations, "values", "staining")
setnames(stainingCombinations, "ind", "uID")

summaryDF <- copy(tcells.sc)
summaryDF$cell_type <- str_extract(summaryDF$pop, "(?<=\\.)[:alnum:]+(?=/)")

for (i in unique(summaryDF$cell_type)) {
  # plot UMAP
  ggplot(
    dfToPlot,
    aes(UMAP_1, UMAP_2)
    ) +
    theme_classic() +
    geom_point(data = summaryDF[cell_type != i], color = "#B3BCC2", size = 4) +
    geom_point(data = summaryDF[cell_type == i], color = "#AA1F5E", size = 4, alpha = 0.5) +
    theme(
      axis.text = element_text(size = 15),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      legend.justification = "right",
      # legend.position = "bottom"
      legend.position = "none",
      axis.line = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank()
      )
  
  ggsave(file.path(anaDir, paste0("umap_", i, ".tiff")), width = 5, height = 5)
}
```

```{r}
# show measurements of clusters to compare
propsToPlot <- copy(tcells.sc)

# propsToPlot <- propsToPlot %>%
#   dplyr::rename(
#     "Movement HMM 1" = "live.cell.hmm.state.movement.1",
#     "Movement HMM 2" = "live.cell.hmm.state.movement.2",
#     "Movement HMM 3" = "live.cell.hmm.state.movement.3",
#     "Movement HMM 4" = "live.cell.hmm.state.movement.4",
#   )

colsToPlot <- colnames(propsToPlot)[!colnames(propsToPlot) %in% c(
  "pop", "uID", "track_id", "clusters", "UMAP_1", "UMAP_2"
  )]

propsToPlot <- propsToPlot %>%
  pivot_longer(
    cols = colsToPlot, names_to = "prop", values_to = "value"
    )

propsToPlot$prop <- factor(propsToPlot$prop, levels = sort(colsToPlot, decreasing = TRUE))

propsToPlot <- .mapClustNames(propsToPlot, clusterMapping, "clusters")

# propsList <- c(
#   'Movement HMM 1',
#   'Movement HMM 2',
#   'Movement HMM 3',
#   'Movement HMM 4',
#   'asphericity',
#   'displacement',
#   'displacementRatio',
#   'duration',
#   'meanTurningAngle',
#   'outreachRatio',
#   'overallAngle',
#   'speed',
#   'straightness',
#   'trackLength'
# )

# show heatmap for clusters
propsSummary <- propsToPlot %>%
  dplyr::filter(
    # clusters.name != "NONE",
    # prop %in% propsList
    ) %>%
  group_by(clusters, prop) %>%
  # group_by(clusters.name, prop) %>%
  summarise(mean = mean(value, rm.na = TRUE)) %>%
  group_by(prop) %>%
  mutate(freq = (mean - min(mean)) / (max(mean) - min(mean))) %>%
  arrange(-prop)
```


```{r fig_clusters_heat, fig.height=8, fig.width=6}
# propsSummary$prop <- factor(
#   propsSummary$prop, levels = rev(propsList))
# propsSummary$clusters.name <- factor(
#   propsSummary$clusters.name, levels = c(
#     "Directed", "Meandering", "Scanning", "Clustering"
#   ))

# # sort states
# propsSummary[!propsSummary$clusters %in% clusterOrder[clusterOrder != 1],]$clusters <- NA
# # propsSummary$clusters <- factor(propsSummary$clusters, levels = clusterOrder)
# propsSummary$clusters <- case_match(
#   as.character(propsSummary$clusters),
#   c("3") ~ "1",
#   c("6") ~ "2",
#   c("0") ~ "3",
#   c("7") ~ "4",
#   c("2") ~ "5",
#   c("5") ~ "6",
#   c("4") ~ "7",
# )

# ggplot(propsSummary, aes(as.factor(clusters.name), prop)) +
# ggplot(propsSummary, aes(as.factor(clusters), prop)) +
ggplot(propsSummary %>%
         dplyr::filter(!str_detect(prop, "live.cell")) %>%
         drop_na(clusters)
         , aes(clusters, prop)) +
  theme_classic() +
  geom_tile(aes(fill = freq), colour = "white", size = 0.5) +
  viridis::scale_fill_viridis(
    breaks = c(0, 1),
    labels = c(0, 1)
  ) +
  theme(
    legend.position = "none",
    legend.key.size = unit(8, "mm"),
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12),
    # axis.text.x = element_text(size = 12, angle = 45, hjust = 1, vjust = 1),
    strip.background = element_blank(),
    strip.text.x = element_blank()
    ) +
  xlab("") + ylab("")

ggsave(file.path(anaDir, "clusters_heat.pdf"), width = 2.8, height = 2.5)
# ggsave(file.path(anaDir, "clusters_heat.pdf"), width = 5, height = 14)
```

```{r fig_clusters_heat, fig.height=2, fig.width=6}
# get frequencies of HMM for each cluster
# and plot as bar graphs
datToPlot <- popDTs %>%
  mutate(live.cell.track.clusters.hmm_transitions_movement = as.numeric(as.character(
    live.cell.track.clusters.hmm_transitions_movement))) %>%
  drop_na(live.cell.track.clusters.hmm_transitions_movement) %>%
  drop_na(live.cell.hmm.state.movement) %>%
  group_by(live.cell.track.clusters.hmm_transitions_movement, live.cell.hmm.state.movement) %>%
  summarise(n = n()) %>%
  mutate(freq = n / sum(n) * 1) %>%
  ungroup() %>%
  complete(live.cell.track.clusters.hmm_transitions_movement, live.cell.hmm.state.movement, fill = list(freq = 0))

data.table::fwrite(datToPlot, file = file.path(anaDir, "freq_hmm.csv"))

ggplot(datToPlot, aes(as.factor(live.cell.track.clusters.hmm_transitions_movement), freq,
                      fill = as.factor(live.cell.hmm.state.movement))) +
  theme_classic() +
  # scale_fill_brewer(palette = "Accent") +
  scale_fill_manual(values = wesanderson::wes_palette(name = "Darjeeling2")) +
  theme_classic() +
  geom_bar(stat = "identity", width = 1, color = "black", size = 0.4) +
  theme(
    # legend.position = "none",
    legend.position = "right",
    legend.key.size = unit(6, "mm"),
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12),
    # axis.text.x = element_text(size = 12, angle = 45, hjust = 1, vjust = 1),
    strip.background = element_blank(),
    # strip.text.x = element_blank()
    strip.text.x = element_text(size = 12)
    ) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  # scale_fill_discrete(name = "HMM State") +
  xlab("") + ylab("") 

ggsave(file.path(anaDir, "clusters_hmm_heat.pdf"), width = 3, height = 1.5)
```

```{r fig_clusters_heat, fig.height=3, fig.width=8}
# get frequencies of HMM for each cluster
# and plot as bar graphs
datToPlot <- popDTs %>%
  mutate(
    live.cell.track.clusters.hmm_transitions_movement = as.numeric(as.character(
      live.cell.track.clusters.hmm_transitions_movement)),
    live.cell.hmm.transitions.movement = as.character(
      live.cell.hmm.transitions.movement)
    ) %>%
  drop_na(live.cell.track.clusters.hmm_transitions_movement) %>%
  dplyr::filter(live.cell.hmm.transitions.movement != "NA") %>%
  # group_by(live.cell.track.clusters.hmm_transitions_movement, from, to) %>%
  # dplyr::filter(!live.cell.hmm.transitions.movement %in% paste0(seq(4), "_", seq(4))) %>%
  group_by(live.cell.track.clusters.hmm_transitions_movement, live.cell.hmm.transitions.movement) %>%
  summarise(n = n()) %>%
  mutate(freq = n / sum(n) * 1) %>%
  separate_wider_delim(
    live.cell.hmm.transitions.movement, delim = "_", names = c("from", "to"))
  # ungroup() %>%
  # complete(live.cell.track.clusters.hmm_transitions_movement, from, to, fill = list(freq = 0))

ggplot(datToPlot, aes(as.factor(from), as.factor(to), size = freq * 2, fill = freq)) +
  theme_classic() +
  # scale_fill_brewer(palette = "Accent") +
  # scale_y_continuous(breaks = c(0, 0.5, 1)) +
  geom_vline(xintercept = as.factor(1:4), color = "#d3d3d3") +
  geom_hline(yintercept = as.factor(1:4), color = "#d3d3d3") +
  geom_point(pch = 21, color = "black") +
  # viridis::scale_fill_viridis() +
  scale_fill_gradient2(
    midpoint = 0.5, low="blue", mid="white", high="red", space ="Lab") +
  theme(
    legend.position = "none",
    # legend.position = "right",
    legend.key.size = unit(6, "mm"),
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12),
    # axis.text.x = element_text(size = 12, angle = 45, hjust = 1, vjust = 1),
    strip.background = element_blank(),
    # strip.text.x = element_blank()
    strip.text.x = element_text(size = 12)
    ) +
  # scale_fill_discrete(name = "HMM State") +
  xlab("From state") + ylab("To state") +
  facet_wrap(.~live.cell.track.clusters.hmm_transitions_movement, nrow = 2)

ggsave(file.path(anaDir, "clusters_transitions_heat.pdf"), width = 4, height = 3)
```

```{r fig_total_transitions, fig.height=1, fig.width=5}
library(ggplot2)
library(ggraph)

freqThr <- 0.0001

pList <- list()

stateOrder <- list(
  "D" = "3",
  "P" = "2",
  "M" = "1",
  "S" = "4"
)

summaryDF <- popDTs %>%
  left_join(exp.info)

summaryDF$cell_type <- str_extract(summaryDF$pop, "(?<=\\.)[:alnum:]+(?=/)")
summaryDF$stain <- str_extract(
  summaryDF$staining, sprintf("%s-[:alnum:]+", summaryDF$cell_type)
  )
summaryDF$stain[is.na(summaryDF$stain)] <- "gBT-CTV"

summaryDF <- .mapClustNames(summaryDF, clusterMapping, "live.cell.track.clusters.hmm_transitions_movement")

# for (x in unique(summaryDF$live.cell.track.clusters.hmm_transitions_movement)) {
for (x in unique(summaryDF$clusters.name)) {
  # plot heatmap of transitions
  DF <- summaryDF %>%
    # dplyr::filter(live.cell.track.clusters.hmm_transitions_movement == x) %>%
    dplyr::filter(clusters.name == x) %>%
    group_by(live.cell.hmm.transitions.movement) %>%
    summarise(n = n()) %>%
    separate(live.cell.hmm.transitions.movement,
             into = c("from", "to"),
             sep = "_", convert = TRUE) %>%
    mutate(across(c(from, to), as.character)) %>%
    replace_na(list(from = "0"))
  
  # edges for non-self transitions
  edges <- DF %>%
    dplyr::filter(from != to) %>%
    mutate(freq = n/sum(n)) %>%
    complete(from, to, fill = list(freq = 0)) %>%
    drop_na() %>%
    dplyr::filter(freq > freqThr) %>%
    mutate(non.self = (freq - min(freq)) / (max(freq) - min(freq))) %>%
    arrange(freq)
  
  # get number of self transitions
  nodes <- DF %>%
    dplyr::filter(from == to) %>%
    mutate(freq = n/sum(n)) %>%
    complete(from = unlist(stateOrder), fill = list(freq = 0)) %>%
    replace_na(list(to = "0")) %>%
    select(from, freq) %>%
    dplyr::rename(node = from) %>%
    add_row(node = "0", freq = 0) %>%
    mutate(nodeName = node) %>%
    dplyr::filter(node %in% unique(c(edges$from, edges$to))) %>%
    mutate(self = (freq - min(freq)) / (max(freq) - min(freq)))
  
  # add names for nodes
  for (i in names(stateOrder)) {
    nodes[nodes$nodeName == stateOrder[[i]], ]$nodeName <- i
  }
  
  # add state order
  counter <- 0
  nodes$order <- 0
  for (y in stateOrder) {
    nodes[nodes$node == y,]$order <- counter

    counter <- counter + 1
  }
  
  # https://www.hydrogenwaterusa.com/visualizing-large-directed-networks-with-ggraph-in-r/
  g <- igraph::graph_from_data_frame(d = edges,
                                     vertices = nodes %>% arrange(order),
                                     directed = TRUE)
  
  # pList[[x]] <- ggraph(g, layout = "auto") +
  # pList[[x]] <- ggraph(g, layout = "igraph", algorithm = "circle") +
  # pList[[x]] <- ggraph(g, layout = "linear") +
  # ggraph(g, layout = "igraph", algorithm = "circle") +
  # ggraph(g, layout = "auto") +
  ggraph(g, layout = "linear") +
    # ggtitle(sprintf("%s", x)) +
    geom_edge_fan2(aes(width = non.self, color = non.self),
                   arrow = arrow(length = unit(5, 'mm'), type = "closed"),
                   end_cap = circle(3, 'mm')) +
    scale_edge_width(range = c(1, 2)) +
    scale_edge_color_gradient2(
      # low = "#D1D1D1",
      low = "#dadada",
      high = "black",
      mid = "#616161",
      midpoint = .5
    ) +
    geom_node_label(aes(label = nodeName, fill = self),
                    color = "white", repel = FALSE, size=5,
                    label.padding = unit(0.25, "lines")) +
    scale_fill_gradient2(
      # low = "blue",
      low = "#009fe3",
      mid = "black",
      # high = "red",
      high = "#e71d73",
      midpoint = .5
    ) +
    theme_graph(
      plot_margin = margin(0, 0, 0, 0)
    ) +
    theme(
      legend.position = "none",
      plot.title = element_text(size = 6, family = "Arial")
    )

  ggsave(file = file.path(anaDir, "networks", paste0("network_", x, ".pdf")),
         width = 3, height = 1, dpi = 400)
}

# ggpubr::ggarrange(plotlist = pList, nrow = 1)

# https://stackoverflow.com/a/17075381
# ggsave(file = file.path(anaDir, "total_networks.tiff"),
# ggsave(file = file.path(anaDir, "total_networks_GCAMP.tiff"),
  # width = 7, height = 2)
  # width = 20, height = 3.5)
  # width = 25, height = 2)
```

```{r fig_clusters_freq, fig.height=4, fig.width=15}
# save frequencies of track clusters
summaryDF <- copy(tcells.sc)

summaryDF <- .mapClustNames(summaryDF, clusterMapping, "clusters")

stainingCombinations <- stack(sapply(
  cciaObj$cciaObjects(uIDs = uIDs),
  function(x) paste(x$imChannelNames(), collapse = ",")
))
setnames(stainingCombinations, "values", "staining")
setnames(stainingCombinations, "ind", "uID")

# show frequency of clusters
summaryDF <- summaryDF[, .(n.clusters = .N), by = .(uID, pop, clusters)] %>%
# summaryDF <- summaryDF[, .(n.clusters = .N), by = .(uID, pop, clusters.name)] %>%
  droplevels() %>%
  group_by(uID, pop) %>%
  mutate(freq.clusters = n.clusters/sum(n.clusters) * 100) %>%
  ungroup() %>%
  complete(uID, pop, clusters, fill = list(freq.clusters = 0)) %>%
  # complete(uID, pop, clusters.name, fill = list(freq.clusters = 0)) %>%
  left_join(exp.info) %>%
  left_join(stainingCombinations)

summaryDF$cell_type <- str_extract(summaryDF$pop, "(?<=\\.)[:alnum:]+(?=/)")
summaryDF$stain <- str_extract(
  summaryDF$staining, sprintf("%s-[:alnum:]+", summaryDF$cell_type)
  )

# ggplot(summaryDF, aes(clusters, freq.clusters, color = interaction(Treatment, dpi))) +
ggplot(summaryDF, aes(clusters, freq.clusters, color = stain)) +
# ggplot(summaryDF, aes(clusters.name, freq.clusters, color = stain)) +
  theme_classic() +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(
    position = position_jitterdodge(jitter.width = 0.10), alpha = 1.0)
  # scale_color_brewer(name = "Treatment", palette = "Set3") 
  # facet_grid(.~pop)

ggsave(file.path(anaDir, "clusters_freq.pdf"), width = 10, height = 3)

summaryDF$Treatment.DTx <- 0
summaryDF[summaryDF$Treatment == "PBS" & summaryDF$DTx == "PBS",]$Treatment.DTx <- 0
summaryDF[summaryDF$Treatment == "HSV" & summaryDF$DTx == "PBS",]$Treatment.DTx <- 1
summaryDF[summaryDF$Treatment == "HSV" & summaryDF$DTx == "DTx",]$Treatment.DTx <- 2

data.table::fwrite(
  summaryDF,
  file = file.path(anaDir, "freq_clusters.csv")
)
```

```{r fig_psuedotime, fig.height=3, fig.width=5}
stainingCombinations <- stack(sapply(
  cciaObj$cciaObjects(uIDs = uIDs),
  function(x) paste(x$imChannelNames(), collapse = ",")
))
setnames(stainingCombinations, "values", "staining")
setnames(stainingCombinations, "ind", "uID")

summaryDF <- copy(tcells.sc) %>%
  left_join(exp.info) %>%
  left_join(stainingCombinations)

summaryDF$cell_type <- str_extract(summaryDF$pop, "(?<=\\.)[:alnum:]+(?=/)")
summaryDF$stain <- str_extract(
  summaryDF$staining, sprintf("%s-[:alnum:]+", summaryDF$cell_type)
  )

summaryDF <- .mapClustNames(summaryDF, clusterMapping)

# summaryDF <- summaryDF[, .(n.clusters = .N), by = .(uID, pop, clusters.name)] %>%
# summaryDF <- summaryDF[, .(n.clusters = .N), by = .(stain, clusters.name)] %>%
# summaryDF <- summaryDF[, .(n.clusters = .N), by = .(stain, clusters)] %>%
summaryDF <- summaryDF[, .(n.clusters = .N), by = .(cell_type, clusters)] %>%
  droplevels() %>%
  # group_by(stain) %>%
  group_by(cell_type) %>%
  mutate(freq.clusters = n.clusters/sum(n.clusters) * 100) %>%
  ungroup() %>%
  # complete(stain, clusters, fill = list(freq.clusters = 0)) %>%
  # mutate(stain = factor(stain, levels = c(
  #   "P14-ubTomato", "P14-CTDR", "OTI-uGFP", "OTI-CTV", "gBT-uGFP", "gBT-CTV"
  # )))
  complete(cell_type, clusters, fill = list(freq.clusters = 0)) %>%
  mutate(cell_type = factor(cell_type, levels = c(
    "P14", "OTI", "gBT"
  )))
  # complete(stain, clusters.name, fill = list(freq.clusters = 0))
  # left_join(stainingCombinations)

summaryDF$cell_type <- recode(
  summaryDF$cell_type,
  "gBT" = 'gBT-I',
  "OTI" = 'OT-I',
  "P14" = 'P14'
)

# ggplot(summaryDF, aes(x = 1, y = freq.clusters, fill = as.factor(clusters.name))) +
# ggplot(summaryDF, aes(x = stain, y = freq.clusters, fill = as.factor(clusters))) +
ggplot(summaryDF, aes(x = cell_type, y = freq.clusters, fill = as.factor(clusters))) +
  scale_fill_brewer(name = NULL, palette = "Set1") +
  theme_classic() +
  geom_bar(stat = "identity", width = 0.8) +
  # geom_col() +
  # coord_polar("y", start = 0) +
  # facet_wrap(.~stain, nrow = 1) +
  # xlim(0, 1.5) +
  theme(
    axis.text = element_text(size = 18),
    legend.key.size = unit(8, "mm"),
    legend.text = element_text(size = 18),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    # axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "right",
    # legend.position = "none",
    legend.title = element_blank(),
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    strip.background = element_blank(),
    # strip.text.x = element_blank()
  ) + coord_flip()

# ggsave(file.path(anaDir, "Behaviour.tiff"), width = 4, height = 2.5)
ggsave(file.path(anaDir, "Behaviour_cell_types.tiff"), width = 4, height = 1.8)
```
